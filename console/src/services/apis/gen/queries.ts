/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Open Attack Surface Management
 * Open-source platform for cybersecurity Attack Surface Management (ASM)
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { orvalClient } from '../axios-client';
export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobStatus = {
  pending: 'pending',
  in_progress: 'in_progress',
  completed: 'completed',
  failed: 'failed',
  cancelled: 'cancelled',
} as const;

export type CronSchedule = (typeof CronSchedule)[keyof typeof CronSchedule];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CronSchedule = {
  disabled: 'disabled',
  '0_0_*_*_*': '0 0 * * *',
  '0_0_*/3_*_*': '0 0 */3 * *',
  '0_0_*_*_0': '0 0 * * 0',
  '0_0_*/14_*_*': '0 0 */14 * *',
  '0_0_1_*_*': '0 0 1 * *',
} as const;

export type Target = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** The target domain (with optional URL path, will be parsed to extract domain) */
  value: string;
  lastDiscoveredAt: string;
  totalAssets: number;
  status: JobStatus;
  scanSchedule: CronSchedule;
};

export type AppResponseSerialization = { [key: string]: unknown };

export type CreateTargetDto = {
  /** The target domain (with optional URL path, will be parsed to extract domain) */
  value: string;
  /** The id of the workspace */
  workspaceId: string;
};

export type GetManyTargetResponseDtoScanSchedule =
  (typeof GetManyTargetResponseDtoScanSchedule)[keyof typeof GetManyTargetResponseDtoScanSchedule];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetManyTargetResponseDtoScanSchedule = {
  disabled: 'disabled',
  '0_0_*_*_*': '0 0 * * *',
  '0_0_*/3_*_*': '0 0 */3 * *',
  '0_0_*_*_0': '0 0 * * 0',
  '0_0_*/14_*_*': '0 0 */14 * *',
  '0_0_1_*_*': '0 0 1 * *',
} as const;

export type GetManyTargetResponseDtoStatus =
  (typeof GetManyTargetResponseDtoStatus)[keyof typeof GetManyTargetResponseDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetManyTargetResponseDtoStatus = {
  RUNNING: 'RUNNING',
  DONE: 'DONE',
} as const;

export type GetManyTargetResponseDto = {
  id: string;
  value: string;
  reScanCount: number;
  scanSchedule: GetManyTargetResponseDtoScanSchedule;
  status: GetManyTargetResponseDtoStatus;
  totalAssets: number;
  duration: number;
  lastDiscoveredAt: string;
};

export type GetManyGetManyTargetResponseDtoDto = {
  data: GetManyTargetResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type DefaultMessageResponseDto = {
  message: string;
};

export type UpdateTargetDtoScanSchedule =
  (typeof UpdateTargetDtoScanSchedule)[keyof typeof UpdateTargetDtoScanSchedule];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateTargetDtoScanSchedule = {
  disabled: 'disabled',
  '0_0_*_*_*': '0 0 * * *',
  '0_0_*/3_*_*': '0 0 */3 * *',
  '0_0_*_*_0': '0 0 * * 0',
  '0_0_*/14_*_*': '0 0 */14 * *',
  '0_0_1_*_*': '0 0 1 * *',
} as const;

export type UpdateTargetDto = {
  scanSchedule: UpdateTargetDtoScanSchedule;
};

export type WorkspaceArchivedAt = { [key: string]: unknown };

export type Workspace = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** The name of the workspace */
  name: string;
  /** The description of the workspace */
  description: string;
  archivedAt?: WorkspaceArchivedAt;
  /** Asset discovery is enabled for the workspace */
  isAssetsDiscovery: boolean;
  /** Assets are automatically enabled after discovery */
  isAutoEnableAssetAfterDiscovered: boolean;
};

export type CreateWorkspaceDtoArchivedAt = { [key: string]: unknown };

export type CreateWorkspaceDto = {
  /** The name of the workspace */
  name: string;
  /** The description of the workspace */
  description: string;
  archivedAt?: CreateWorkspaceDtoArchivedAt;
};

export type GetApiKeyResponseDto = {
  apiKey: string;
};

export type SwaggerPropertyMetadataValue = { [key: string]: unknown };

export type SwaggerPropertyMetadataExample = { [key: string]: unknown };

export type SwaggerPropertyMetadataDescription = { [key: string]: unknown };

export type SwaggerPropertyMetadata = {
  value: SwaggerPropertyMetadataValue;
  type: string;
  example: SwaggerPropertyMetadataExample;
  description: SwaggerPropertyMetadataDescription;
  title: string;
};

export type GetWorkspaceConfigsDto = {
  isAssetsDiscovery: SwaggerPropertyMetadata;
  isAutoEnableAssetAfterDiscovered: SwaggerPropertyMetadata;
};

export type UpdateWorkspaceConfigsDto = {
  /** Asset discovery is enabled for the workspace */
  isAssetsDiscovery: boolean;
  /** Assets are automatically enabled after discovery */
  isAutoEnableAssetAfterDiscovered: boolean;
};

export type GetManyWorkspaceDto = {
  data: Workspace[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type UpdateWorkspaceDtoArchivedAt = { [key: string]: unknown };

export type UpdateWorkspaceDto = {
  /** The name of the workspace */
  name?: string;
  /** The description of the workspace */
  description?: string;
  archivedAt?: UpdateWorkspaceDtoArchivedAt;
};

export type ArchiveWorkspaceDto = {
  /** Whether to archive (true) or unarchive (false) the workspace */
  isArchived: boolean;
};

export type String = { [key: string]: unknown };

export type GetManyStringDto = {
  data: string[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

/**
 * The workflow content
 */
export type GetManyWorkflowsResponseDtoContent = { [key: string]: unknown };

/**
 * The user who created this workflow
 */
export type GetManyWorkflowsResponseDtoCreatedBy = { [key: string]: unknown };

/**
 * The workspace this workflow belongs to
 */
export type GetManyWorkflowsResponseDtoWorkspace = { [key: string]: unknown };

export type GetManyWorkflowsResponseDto = {
  /** The unique identifier of the workflow */
  id: string;
  /** The name of the workflow */
  name: string;
  /** The file path of the workflow */
  filePath: string;
  /** The workflow content */
  content: GetManyWorkflowsResponseDtoContent;
  /** When the workflow was created */
  createdAt: string;
  /** When the workflow was last updated */
  updatedAt: string;
  /** The user who created this workflow */
  createdBy?: GetManyWorkflowsResponseDtoCreatedBy;
  /** The workspace this workflow belongs to */
  workspace?: GetManyWorkflowsResponseDtoWorkspace;
};

export type GetManyGetManyWorkflowsResponseDtoDto = {
  data: GetManyWorkflowsResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type OnSchedule = (typeof OnSchedule)[keyof typeof OnSchedule];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OnSchedule = {
  disabled: 'disabled',
  '0_0_*_*_*': '0 0 * * *',
  '0_0_*/3_*_*': '0 0 */3 * *',
  '0_0_*_*_0': '0 0 * * 0',
  '0_0_*/14_*_*': '0 0 */14 * *',
  '0_0_1_*_*': '0 0 1 * *',
} as const;

export type On = {
  target: string[];
  schedule: OnSchedule;
};

export type WorkflowJob = {
  name: string;
  run: string;
};

export type WorkflowContent = {
  on: On;
  jobs: WorkflowJob[];
  name: string;
};

export type Workflow = {
  id: string;
  createdAt: string;
  updatedAt: string;
  content: WorkflowContent;
  isCanDelete: boolean;
  isCanEdit: boolean;
};

export type CreateWorkflowDto = {
  /** Name of the workflow */
  name: string;
  /** Content of the workflow in JSON format */
  content: WorkflowContent;
  /** File path for the workflow */
  filePath?: string;
};

export type UpdateWorkflowDto = {
  /** Name of the workflow */
  name?: string;
  /** Content of the workflow in JSON format */
  content?: WorkflowContent;
  /** File path for the workflow */
  filePath?: string;
};

export type CreateFirstAdminDto = {
  email: string;
  password: string;
};

export type GetMetadataDto = {
  isInit: boolean;
  isAssistant: boolean;
};

export type GenerateTagsResponseDto = {
  /** Domain that tags were generated for */
  domain: string;
  /** Generated tags */
  tags: string[];
};

export type GenerateTagsDto = {
  /** Domain to generate tags for */
  domain: string;
};

/**
 * MCP servers configuration with embedded status
 */
export type GetMcpServersResponseDtoMcpServers = { [key: string]: unknown };

export type GetMcpServersResponseDto = {
  /** MCP servers configuration with embedded status */
  mcpServers: GetMcpServersResponseDtoMcpServers;
};

/**
 * MCP servers configuration with status
 */
export type AddMcpServersResponseDtoMcpServers = { [key: string]: unknown };

export type AddMcpServersResponseDto = {
  /** Config ID */
  id?: string;
  /** Workspace ID */
  workspace_id?: string;
  /** User ID */
  user_id?: string;
  /** Created timestamp */
  created_at?: string;
  /** Updated timestamp */
  updated_at?: string;
  /** MCP servers configuration with status */
  mcpServers: AddMcpServersResponseDtoMcpServers;
  /** Whether the operation succeeded */
  success: boolean;
  /** Error message if operation failed */
  error?: string;
};

/**
 * MCP servers configuration object
 */
export type AddMcpServersDtoMcpServers = { [key: string]: unknown };

export type AddMcpServersDto = {
  /** MCP servers configuration object */
  mcpServers: AddMcpServersDtoMcpServers;
};

/**
 * Updated MCP servers configuration with status
 */
export type UpdateMcpServersResponseDtoMcpServers = { [key: string]: unknown };

export type UpdateMcpServersResponseDto = {
  /** Config ID */
  id?: string;
  /** Workspace ID */
  workspace_id?: string;
  /** User ID */
  user_id?: string;
  /** Created timestamp */
  created_at?: string;
  /** Updated timestamp */
  updated_at?: string;
  /** Updated MCP servers configuration with status */
  mcpServers: UpdateMcpServersResponseDtoMcpServers;
  /** Whether the operation succeeded */
  success: boolean;
};

/**
 * MCP servers configuration object
 */
export type UpdateMcpServersDtoMcpServers = { [key: string]: unknown };

export type UpdateMcpServersDto = {
  /** MCP servers configuration object */
  mcpServers: UpdateMcpServersDtoMcpServers;
};

export type DeleteMcpServersResponseDto = {
  /** Whether the operation succeeded */
  success: boolean;
  /** Response message */
  message?: string;
};

/**
 * Server status: active, disabled, or error
 */
export type GetMcpServerHealthResponseDtoStatus =
  (typeof GetMcpServerHealthResponseDtoStatus)[keyof typeof GetMcpServerHealthResponseDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMcpServerHealthResponseDtoStatus = {
  active: 'active',
  disabled: 'disabled',
  error: 'error',
} as const;

export type GetMcpServerHealthResponseDto = {
  /** Whether the server is active and operational */
  isActive: boolean;
  /** Server status: active, disabled, or error */
  status: GetMcpServerHealthResponseDtoStatus;
  /** Error message if status is error */
  error?: string;
};

export type GetConversationsResponseDtoConversationsItem = {
  conversationId?: string;
  title?: string;
  description?: string;
  createdAt?: string;
  updatedAt?: string;
};

export type GetConversationsResponseDto = {
  /** List of conversations */
  conversations: GetConversationsResponseDtoConversationsItem[];
  /** Total count of conversations */
  totalCount: number;
};

/**
 * Updated conversation
 */
export type UpdateConversationResponseDtoConversation = {
  conversationId?: string;
  title?: string;
  description?: string;
  createdAt?: string;
  updatedAt?: string;
};

export type UpdateConversationResponseDto = {
  /** Updated conversation */
  conversation: UpdateConversationResponseDtoConversation;
};

export type UpdateConversationDto = {
  /** New title for the conversation */
  title?: string;
  /** New description for the conversation */
  description?: string;
};

export type DeleteConversationResponseDto = {
  /** Success status */
  success: boolean;
  /** Response message */
  message: string;
};

export type DeleteConversationsResponseDto = {
  /** Success status */
  success: boolean;
  /** Response message */
  message: string;
};

export type GetMessagesResponseDtoMessagesItem = {
  messageId?: string;
  question?: string;
  type?: string;
  content?: string;
  conversationId?: string;
  createdAt?: string;
  updatedAt?: string;
};

export type GetMessagesResponseDto = {
  /** List of messages in the conversation */
  messages: GetMessagesResponseDtoMessagesItem[];
};

export type DeleteMessageResponseDto = {
  /** Success status */
  success: boolean;
  /** Response message */
  message: string;
};

export type ModelInfoResponseDto = {
  id: string;
  name: string;
  provider: string;
  description: string;
  isActive: boolean;
  isRecommended: boolean;
};

export type LLMConfigResponseDto = {
  id: string;
  provider: string;
  apiKey: string;
  model: string;
  isPreferred: boolean;
  isEditable: boolean;
};

export type UpdateLLMConfigDto = {
  id?: string;
  provider: string;
  apiKey: string;
  model?: string;
};

export type AssetDnsRecords = { [key: string]: unknown };

export type Asset = {
  id: string;
  createdAt: string;
  updatedAt: string;
  value: string;
  targetId: string;
  isPrimary: boolean;
  dnsRecords: AssetDnsRecords;
  isEnabled: boolean;
};

export type ToolCategory = (typeof ToolCategory)[keyof typeof ToolCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolCategory = {
  subdomains: 'subdomains',
  http_probe: 'http_probe',
  ports_scanner: 'ports_scanner',
  vulnerabilities: 'vulnerabilities',
  classifier: 'classifier',
  assistant: 'assistant',
} as const;

export type Tool = {
  id: string;
  createdAt: string;
  updatedAt: string;
  name: string;
  description: string;
  category: ToolCategory;
  version: string;
  /** @nullable */
  logoUrl?: string | null;
  isInstalled: boolean;
  isOfficialSupport: boolean;
  type: string;
  providerId: string;
};

export type AssetService = {
  id: string;
  createdAt: string;
  updatedAt: string;
  value: string;
  port: number;
  assetId: string;
  isErrorPage: boolean;
};

export type JobErrorLog = {
  id: string;
  createdAt: string;
  updatedAt: string;
  logMessage: string;
  payload: string;
  jobId: string;
};

export type Job = {
  id: string;
  createdAt: string;
  updatedAt: string;
  asset: Asset;
  category: string;
  status: string;
  pickJobAt: string;
  tool: Tool;
  completedAt: string;
  command: string;
  assetServiceId: string;
  assetService: AssetService;
  errorLogs: JobErrorLog[];
};

export type GetManyJobDto = {
  data: Job[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type JobTimelineItem = {
  name: string;
  target: string;
  targetId: string;
  jobHistoryId: string;
  startTime: string;
  endTime: string;
  status: string;
  description: string;
  toolCategory: string;
  duration: number;
};

export type JobTimelineResponseDto = {
  data: JobTimelineItem[];
};

export type GetNextJobResponseDto = {
  id: string;
  createdAt: string;
  updatedAt: string;
  category: string;
  status: string;
  command: string;
  asset: string;
};

export type DataPayloadResultPayload = { [key: string]: unknown };

export type DataPayloadResult = {
  error: boolean;
  raw: string;
  payload: DataPayloadResultPayload;
};

export type UpdateResultDto = {
  jobId: string;
  data: DataPayloadResult;
};

export type CreateJobsDto = {
  toolIds: string[];
  targetId: string;
};

export type JobHistoryResponseDtoStatus =
  (typeof JobHistoryResponseDtoStatus)[keyof typeof JobHistoryResponseDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobHistoryResponseDtoStatus = {
  pending: 'pending',
  in_progress: 'in_progress',
  completed: 'completed',
  failed: 'failed',
  cancelled: 'cancelled',
} as const;

export type JobHistoryResponseDto = {
  id: string;
  createdAt: string;
  updatedAt: string;
  totalJobs: number;
  status: JobHistoryResponseDtoStatus;
  workflowName: string;
};

export type GetManyJobHistoryResponseDtoDto = {
  data: JobHistoryResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type JobHistoryDetailResponseDto = {
  id: string;
  createdAt: string;
  updatedAt: string;
  tools: Tool[];
  jobs: Job[];
  workflowName: string;
};

export type PickTypeClass = {
  id: string;
  name: string;
};

export type AssetTag = {
  id: string;
  createdAt: string;
  updatedAt: string;
  tag: string;
  tool: PickTypeClass;
};

export type TlsInfoFingerprintHash = { [key: string]: unknown };

export type TlsInfo = {
  host: string;
  port: string;
  probe_status: boolean;
  tls_version: string;
  cipher: string;
  not_before: string;
  not_after: string;
  subject_dn: string;
  subject_cn: string;
  subject_an: string[];
  serial: string;
  issuer_dn: string;
  issuer_cn: string;
  issuer_org: string[];
  fingerprint_hash: TlsInfoFingerprintHash;
  wildcard_certificate: boolean;
  tls_connection: string;
  sni: string;
};

export type KnowledgebaseInfo = {
  PageType: string;
  pHash: number;
};

export type HttpResponseDTOHeader = { [key: string]: unknown };

export type HttpResponseDTO = {
  id: string;
  createdAt: string;
  updatedAt: string;
  timestamp: string;
  tls: TlsInfo;
  port: string;
  url: string;
  input: string;
  title: string;
  scheme: string;
  webserver: string;
  body: string;
  content_type: string;
  method: string;
  host: string;
  path: string;
  favicon: string;
  favicon_md5: string;
  favicon_url: string;
  header: HttpResponseDTOHeader;
  raw_header: string;
  request: string;
  time: string;
  a: string[];
  tech: string[];
  words: number;
  lines: number;
  status_code: number;
  content_length: number;
  failed: boolean;
  knowledgebase: KnowledgebaseInfo;
  resolvers: string[];
  chain_status_codes: string[];
  assetServiceId: string;
  jobHistoryId: string;
  techList: string[];
};

export type GetAssetsResponseDtoDnsRecords = { [key: string]: unknown };

export type GetAssetsResponseDto = {
  id: string;
  value: string;
  targetId: string;
  isPrimary?: boolean;
  createdAt: string;
  updatedAt: string;
  tags: AssetTag[];
  dnsRecords?: GetAssetsResponseDtoDnsRecords;
  ipAddresses: string[];
  httpResponses?: HttpResponseDTO;
  port?: number;
  isEnabled: boolean;
};

export type GetManyGetAssetsResponseDtoDto = {
  data: GetAssetsResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type GetIpAssetsDTO = {
  ip: string;
  assetCount: number;
};

export type GetManyGetIpAssetsDTODto = {
  data: GetIpAssetsDTO[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type GetHostAssetsDTO = {
  host: string;
  assetCount: number;
};

export type GetManyGetHostAssetsDTODto = {
  data: GetHostAssetsDTO[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type GetPortAssetsDTO = {
  port: string;
  assetCount: number;
};

export type GetManyGetPortAssetsDTODto = {
  data: GetPortAssetsDTO[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type TechnologyDetailDTOJs = { [key: string]: unknown };

export type TechnologyDetailDTOMeta = { [key: string]: unknown };

export type TechnologyDetailDTOHeaders = { [key: string]: unknown };

export type TechnologyDetailDTOCookies = { [key: string]: unknown };

export type TechnologyDetailDTODns = { [key: string]: unknown };

export type TechnologyDetailDTO = {
  name: string;
  cats?: string[];
  version?: string;
  description?: string;
  html?: string[];
  icon?: string;
  implies?: string[];
  js?: TechnologyDetailDTOJs;
  oss?: boolean;
  scriptSrc?: string[];
  website?: string;
  pricing?: string[];
  saas?: boolean;
  dom?: string[];
  meta?: TechnologyDetailDTOMeta;
  headers?: TechnologyDetailDTOHeaders;
  cookies?: TechnologyDetailDTOCookies;
  dns?: TechnologyDetailDTODns;
  url?: string[];
  scripts?: string[];
  xhr?: string[];
  requires?: string[];
  categories?: string[];
  iconUrl?: string;
  categoryNames?: string[];
};

export type GetTechnologyAssetsDTO = {
  technology: TechnologyDetailDTO;
  assetCount: number;
};

export type GetManyGetTechnologyAssetsDTODto = {
  data: GetTechnologyAssetsDTO[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type GetStatusCodeAssetsDTO = {
  statusCode: string;
  assetCount: number;
};

export type GetManyGetStatusCodeAssetsDTODto = {
  data: GetStatusCodeAssetsDTO[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type GetTlsResponseDto = {
  host: string;
  sni: string;
  subject_dn: string;
  subject_an: string[];
  not_after: string;
  not_before: string;
  tls_connection: string;
};

export type GetManyGetTlsResponseDtoDto = {
  data: GetTlsResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type UpdateAssetDto = {
  /** @nullable */
  tags: string[] | null;
};

export type SwitchAssetDto = {
  assetId: string;
  isEnabled: boolean;
};

export type WorkerAliveDto = {
  token: string;
};

export type WorkerInstance = {
  id: string;
  createdAt: string;
  updatedAt: string;
  lastSeenAt: string;
  token: string;
  currentJobsCount: number;
  type: string;
  scope: string;
  tool: Tool;
};

export type WorkerJoinDto = {
  apiKey: string;
};

export type GetManyWorkerInstanceDto = {
  data: WorkerInstance[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type SearchData = {
  assets: Asset[];
  targets: Target[];
};

export type SearchResponseDto = {
  data: SearchData;
  total: number;
  page: number;
  limit: number;
  pageCount: number;
  hasNextPage: boolean;
};

export type GetSearchHistoryResponseDto = {
  id: string;
  query: string;
  workspaceId: string;
  createdAt: string;
  updatedAt: string;
};

export type GetManyGetSearchHistoryResponseDtoDto = {
  data: GetSearchHistoryResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type DeleteResponseDto = {
  /** Tr·∫°ng th√°i x√≥a th√†nh c√¥ng */
  success: boolean;
};

export type StatisticResponseDto = {
  /** Number of assets */
  assets: number;
  /** Number of targets */
  targets: number;
  /** Number of vulnerabilities */
  vuls: number;
  /** Number of critical vulnerabilities */
  criticalVuls: number;
  /** Number of high severity vulnerabilities */
  highVuls: number;
  /** Number of medium severity vulnerabilities */
  mediumVuls: number;
  /** Number of low severity vulnerabilities */
  lowVuls: number;
  /** Number of info severity vulnerabilities */
  infoVuls: number;
  /** Number of technologies detected */
  techs: number;
  /** Number of ports */
  ports: number;
  /** Security score */
  score: number;
};

export type Statistic = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** Number of assets */
  assets: number;
  /** Number of targets */
  targets: number;
  /** Number of vulnerabilities */
  vuls: number;
  /** Number of critical vulnerabilities */
  criticalVuls: number;
  /** Number of high severity vulnerabilities */
  highVuls: number;
  /** Number of medium severity vulnerabilities */
  mediumVuls: number;
  /** Number of low severity vulnerabilities */
  lowVuls: number;
  /** Number of info severity vulnerabilities */
  infoVuls: number;
  /** Number of technologies detected */
  techs: number;
  /** Number of ports */
  ports: number;
  /** Security score */
  score: number;
};

export type TimelineResponseDto = {
  /** List of statistics over time */
  data: Statistic[];
  /** Total count of timeline records */
  total: number;
};

export type IssuesTimelineItem = {
  /** Number of vulnerabilities */
  vuls: number;
  /** Creation timestamp */
  createdAt: string;
};

export type IssuesTimelineResponseDto = {
  /** List of issues over time */
  data: IssuesTimelineItem[];
  /** Total count of issues timeline records */
  total: number;
};

export type TopTagAsset = {
  /** The name of the tag */
  tag: string;
  /** The number of assets associated with the tag */
  count: number;
};

export type GeoIp = {
  query: string;
  status: string;
  continent: string;
  continentCode: string;
  country: string;
  countryCode: string;
  region: string;
  regionName: string;
  city: string;
  district: string;
  zip: string;
  lat: number;
  lon: number;
  timezone: string;
  offset: number;
  currency: string;
  isp: string;
  org: string;
  as: string;
  asname: string;
};

export type TopAssetVulnerabilities = {
  /** The number of critical vulnerabilities */
  critical: number;
  /** The number of high severity vulnerabilities */
  high: number;
  /** The number of medium severity vulnerabilities */
  medium: number;
  /** The number of low severity vulnerabilities */
  low: number;
  /** The number of info severity vulnerabilities */
  info: number;
  /** The total number of vulnerabilities */
  total: number;
  /** The ID of the asset */
  id: string;
  /** The value of the asset */
  value: string;
};

export type ScanDto = {
  /** Target ID */
  targetId: string;
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserRole = {
  admin: 'admin',
  user: 'user',
  bot: 'bot',
} as const;

export type User = {
  id: string;
  createdAt: string;
  updatedAt: string;
  name: string;
  role: UserRole;
};

export type Vulnerability = {
  id: string;
  createdAt: string;
  updatedAt: string;
  name: string;
  description: string;
  synopsis: string;
  severity: string;
  tags: string[];
  references: string[];
  authors: string[];
  affectedUrl: string;
  ipAddress: string;
  host: string;
  ports: string[];
  cvssMetric: string;
  cvssScore: number;
  epssScore: number;
  vprScore: number;
  cveId: string[];
  bidId: string[];
  cweId: string[];
  ceaId: string[];
  iava: string[];
  cveUrl: string;
  cweUrl: string;
  solution: string;
  extractorName: string;
  extractedResults: string[];
  publicationDate: string;
  modificationDate: string;
  tool: Tool;
  vulnerabilityDismissal: VulnerabilityDismissal;
};

export type VulnerabilityDismissal = {
  id: string;
  createdAt: string;
  updatedAt: string;
  vulnerabilityId: string;
  userId: string;
  reason: string;
  comment: string;
  user: User;
  vulnerability: Vulnerability;
};

export type GetManyVulnerabilityDto = {
  data: Vulnerability[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type VulnerabilityStatisticsDtoSeverity =
  (typeof VulnerabilityStatisticsDtoSeverity)[keyof typeof VulnerabilityStatisticsDtoSeverity];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VulnerabilityStatisticsDtoSeverity = {
  info: 'info',
  low: 'low',
  medium: 'medium',
  high: 'high',
  critical: 'critical',
} as const;

export type VulnerabilityStatisticsDto = {
  severity: VulnerabilityStatisticsDtoSeverity;
  count: number;
};

export type GetVulnerabilitiesStatisticsResponseDto = {
  data: VulnerabilityStatisticsDto[];
};

export type BulkDismissVulnerabilitiesDto = {
  ids: string[];
  reason: string;
  /** @nullable */
  comment: string | null;
};

export type BulkReopenVulnerabilitiesDto = {
  ids: string[];
};

export type CreateToolDtoCategory =
  (typeof CreateToolDtoCategory)[keyof typeof CreateToolDtoCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateToolDtoCategory = {
  subdomains: 'subdomains',
  http_probe: 'http_probe',
  ports_scanner: 'ports_scanner',
  vulnerabilities: 'vulnerabilities',
  classifier: 'classifier',
  assistant: 'assistant',
} as const;

export type CreateToolDto = {
  name: string;
  description: string;
  category: CreateToolDtoCategory;
  version: string;
  /** @nullable */
  logoUrl?: string | null;
  /** The ID of the provider */
  providerId: string;
};

export type WorkspaceTool = {
  id: string;
  createdAt: string;
  updatedAt: string;
};

export type AddToolToWorkspaceDto = {
  /** The ID of the workspace */
  workspaceId: string;
  /** The ID of the tool */
  toolId: string;
};

export type InstallToolDto = {
  /** The ID of the workspace */
  workspaceId: string;
  /** The ID of the tool */
  toolId: string;
};

export type GetManyToolDto = {
  data: Tool[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type ToolProvider = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** Provider name */
  name: string;
  /** Unique code/slug for provider */
  code: string;
  /** Provider description */
  description: string;
  /** Logo URL */
  logoUrl: string;
  /** Official website URL */
  websiteUrl: string;
  /** Support email */
  supportEmail: string;
  /** Company name */
  company: string;
  /** License info */
  licenseInfo: string;
  /** API documentation URL */
  apiDocsUrl: string;
  /** Is provider active */
  isActive: boolean;
};

export type GetManyToolProviderDto = {
  data: ToolProvider[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type CreateProviderDto = {
  /** Provider name */
  name: string;
  /** Unique code/slug for provider */
  code: string;
  /** Provider description */
  description: string;
  /** Logo URL */
  logoUrl: string;
  /** Official website URL */
  websiteUrl: string;
  /** Support email */
  supportEmail: string;
  /** Company name */
  company: string;
  /** License info */
  licenseInfo: string;
  /** API documentation URL */
  apiDocsUrl: string;
};

export type UpdateProviderDto = {
  /** Provider name */
  name?: string;
  /** Unique code/slug for provider */
  code?: string;
  /** Provider description */
  description?: string;
  /** Logo URL */
  logoUrl?: string;
  /** Official website URL */
  websiteUrl?: string;
  /** Support email */
  supportEmail?: string;
  /** Company name */
  company?: string;
  /** License info */
  licenseInfo?: string;
  /** API documentation URL */
  apiDocsUrl?: string;
};

export type Template = {
  id: string;
  createdAt: string;
  updatedAt: string;
  fileName: string;
  path: string;
};

export type CreateTemplateDTO = {
  fileName: string;
};

export type UploadTemplateResponseDTO = {
  path: string;
};

export type UploadTemplateDTO = {
  templateId: string;
  fileContent: string;
};

export type RenameTemplateDTO = {
  fileName: string;
};

export type GetManyTemplateDto = {
  data: Template[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type RunTemplateDto = {
  templateId: string;
  assetId: string;
};

export type AssetGroup = {
  id: string;
  createdAt: string;
  updatedAt: string;
  name: string;
  hexColor?: string;
  totalAssets: number;
};

export type GetManyAssetGroupDto = {
  data: AssetGroup[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type UpdateAssetGroupDto = {
  /** Name of the asset group */
  name?: string;
  /** Hex color of the asset group */
  hexColor?: string;
};

export type CreateAssetGroupDto = {
  /** Name of the asset group */
  name: string;
};

export type AddManyWorkflowsToAssetGroupDto = {
  /** Array of workflow IDs to add */
  workflowIds: string[];
};

export type AddManyAssetsToAssetGroupDto = {
  /** Array of asset IDs to add */
  assetIds: string[];
};

export type RemoveManyWorkflowsFromAssetGroupDto = {
  /** Array of workflow IDs to remove */
  workflowIds: string[];
};

export type RemoveManyAssetsFromAssetGroupDto = {
  /** Array of asset IDs to remove */
  assetIds: string[];
};

export type GetManyAssetDto = {
  data: Asset[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type AssetGroupWorkflowSchedule =
  (typeof AssetGroupWorkflowSchedule)[keyof typeof AssetGroupWorkflowSchedule];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssetGroupWorkflowSchedule = {
  disabled: 'disabled',
  '0_0_*_*_*': '0 0 * * *',
  '0_0_*/3_*_*': '0 0 */3 * *',
  '0_0_*_*_0': '0 0 * * 0',
  '0_0_*/14_*_*': '0 0 */14 * *',
  '0_0_1_*_*': '0 0 1 * *',
} as const;

export type AssetGroupWorkflow = {
  id: string;
  createdAt: string;
  updatedAt: string;
  assetGroup: AssetGroup;
  workflow: Workflow;
  schedule: AssetGroupWorkflowSchedule;
};

export type GetManyAssetGroupWorkflowDto = {
  data: AssetGroupWorkflow[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type GetManyWorkflowDto = {
  data: Workflow[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type UpdateAssetGroupWorkflowDtoSchedule =
  (typeof UpdateAssetGroupWorkflowDtoSchedule)[keyof typeof UpdateAssetGroupWorkflowDtoSchedule];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateAssetGroupWorkflowDtoSchedule = {
  disabled: 'disabled',
  '0_0_*_*_*': '0 0 * * *',
  '0_0_*/3_*_*': '0 0 */3 * *',
  '0_0_*_*_0': '0 0 * * 0',
  '0_0_*/14_*_*': '0 0 */14 * *',
  '0_0_1_*_*': '0 0 1 * *',
} as const;

export type UpdateAssetGroupWorkflowDto = {
  schedule: UpdateAssetGroupWorkflowDtoSchedule;
};

export type Issue = {
  id: string;
  createdAt: string;
  updatedAt: string;
  title: string;
  description: string;
  status: string;
  sourceType: string;
  sourceId: string;
  workspaceId: string;
  no: number;
  tags: string[];
  createdBy: User;
};

export type GetManyIssueDto = {
  data: Issue[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type CreateIssueDtoSourceType =
  (typeof CreateIssueDtoSourceType)[keyof typeof CreateIssueDtoSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateIssueDtoSourceType = {
  vulnerability: 'vulnerability',
} as const;

export type CreateIssueDto = {
  title: string;
  description: string;
  tags?: string[];
  sourceType: CreateIssueDtoSourceType;
  sourceId: string;
};

export type UpdateIssueDto = {
  title?: string;
  tags?: string[];
};

export type ChangeIssueStatusDtoStatus =
  (typeof ChangeIssueStatusDtoStatus)[keyof typeof ChangeIssueStatusDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChangeIssueStatusDtoStatus = {
  open: 'open',
  closed: 'closed',
} as const;

export type ChangeIssueStatusDto = {
  status: ChangeIssueStatusDtoStatus;
};

export type IssueCommentType =
  (typeof IssueCommentType)[keyof typeof IssueCommentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IssueCommentType = {
  content: 'content',
  open: 'open',
  closed: 'closed',
} as const;

export type IssueComment = {
  id: string;
  createdAt: string;
  updatedAt: string;
  content: string;
  createdBy: User;
  isCanDelete: boolean;
  isCanEdit: boolean;
  type: IssueCommentType;
  repCommentId?: string;
  repComment: IssueComment;
};

export type CreateIssueCommentDto = {
  content: string;
  repCommentId?: string;
};

export type GetManyIssueCommentDto = {
  data: IssueComment[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type UpdateIssueCommentDto = {
  /** Content of the comment */
  content: string;
};

export type Object = { [key: string]: unknown };

export type NotificationResponseDtoStatus =
  (typeof NotificationResponseDtoStatus)[keyof typeof NotificationResponseDtoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationResponseDtoStatus = {
  sent: 'sent',
  unread: 'unread',
  read: 'read',
} as const;

export type NotificationResponseDto = {
  id: string;
  status: NotificationResponseDtoStatus;
  createdAt: string;
  updatedAt: string;
  message: string;
  url: string;
};

export type GetManyNotificationResponseDtoDto = {
  data: NotificationResponseDto[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

/**
 * Type of the notification
 */
export type CreateNotificationDtoScope =
  (typeof CreateNotificationDtoScope)[keyof typeof CreateNotificationDtoScope];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateNotificationDtoScope = {
  SYSTEM: 'SYSTEM',
  USER: 'USER',
  GROUP: 'GROUP',
} as const;

/**
 * Type of the notification
 */
export type CreateNotificationDtoType =
  (typeof CreateNotificationDtoType)[keyof typeof CreateNotificationDtoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateNotificationDtoType = {
  WORKSPACE_CREATED: 'WORKSPACE_CREATED',
} as const;

/**
 * Metadata for the notification content (variables for translation)
 */
export type CreateNotificationDtoMetadata = { [key: string]: unknown };

export type CreateNotificationDto = {
  /** List of user IDs to receive the notification */
  recipients: string[];
  /** Type of the notification */
  scope: CreateNotificationDtoScope;
  /** Type of the notification */
  type: CreateNotificationDtoType;
  /** Metadata for the notification content (variables for translation) */
  metadata?: CreateNotificationDtoMetadata;
};

export type McpTool = {
  name: string;
  type: string;
  description: string;
  moduleId: string;
};

export type McpPermissionValue = {
  workspaceId: string;
  permissions: string[];
};

export type CreateMcpPermissionsRequestDto = {
  name: string;
  description?: string;
  value: McpPermissionValue[];
};

export type McpPermission = {
  id: string;
  createdAt: string;
  updatedAt: string;
  name: string;
  description?: string;
  value: McpPermissionValue[];
};

export type GetManyMcpPermissionDto = {
  data: McpPermission[];
  total: number;
  page: number;
  limit: number;
  hasNextPage: boolean;
  pageCount: number;
};

export type TargetsControllerGetTargetsInWorkspaceParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
};

export type WorkspacesControllerGetWorkspacesParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  /**
   * Whether to archive (true) or unarchive (false) the workspace
   */
  isArchived?: boolean;
};

export type WorkflowsControllerGetManyWorkflowsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  /**
   * Filter by workflow name
   */
  name?: string;
};

export type AiAssistantControllerGetConversationsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type AiAssistantControllerGetAvailableModels200 =
  AppResponseSerialization & {
    data?: ModelInfoResponseDto[];
  };

export type AiAssistantControllerGetLLMConfigsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type AiAssistantControllerGetLLMConfigs200 = AppResponseSerialization & {
  data?: LLMConfigResponseDto[];
};

export type JobsRegistryControllerGetManyJobsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  jobHistoryId?: string;
};

export type JobsRegistryControllerGetManyJobHistoriesParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type AssetsControllerGetAssetsInWorkspaceParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
  targetIds?: string[];
  ipAddresses?: string[];
  ports?: string[];
  hosts?: string[];
  techs?: string[];
  statusCodes?: string[];
};

export type AssetsControllerGetIpAssetsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
  targetIds?: string[];
  ipAddresses?: string[];
  ports?: string[];
  hosts?: string[];
  techs?: string[];
  statusCodes?: string[];
};

export type AssetsControllerGetHostAssetsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
  targetIds?: string[];
  ipAddresses?: string[];
  ports?: string[];
  hosts?: string[];
  techs?: string[];
  statusCodes?: string[];
};

export type AssetsControllerGetPortAssetsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
  targetIds?: string[];
  ipAddresses?: string[];
  ports?: string[];
  hosts?: string[];
  techs?: string[];
  statusCodes?: string[];
};

export type AssetsControllerGetTechnologyAssetsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
  targetIds?: string[];
  ipAddresses?: string[];
  ports?: string[];
  hosts?: string[];
  techs?: string[];
  statusCodes?: string[];
};

export type AssetsControllerGetStatusCodeAssetsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
  targetIds?: string[];
  ipAddresses?: string[];
  ports?: string[];
  hosts?: string[];
  techs?: string[];
  statusCodes?: string[];
};

export type WorkersControllerGetWorkersParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  workspaceId?: string;
};

export type SearchControllerSearchAssetsTargetsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value: string;
  workspaceId: string;
  isSaveHistory?: boolean;
};

export type SearchControllerGetSearchHistoryParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  workspaceId: string;
  query?: string;
};

export type StatisticControllerGetStatisticsParams = {
  /**
   * The ID of the workspace to get statistics for
   */
  workspaceId: string;
};

export type VulnerabilitiesControllerGetVulnerabilitiesParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  workspaceId: string;
  targetIds?: string[];
  q?: string;
  /**
   * Filter by vulnerability status: open, dismissed, or all
   */
  status?: VulnerabilitiesControllerGetVulnerabilitiesStatus;
};

export type VulnerabilitiesControllerGetVulnerabilitiesStatus =
  (typeof VulnerabilitiesControllerGetVulnerabilitiesStatus)[keyof typeof VulnerabilitiesControllerGetVulnerabilitiesStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VulnerabilitiesControllerGetVulnerabilitiesStatus = {
  open: 'open',
  dismissed: 'dismissed',
  all: 'all',
} as const;

export type VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams = {
  workspaceId: string;
  targetIds?: string[];
};

export type VulnerabilitiesControllerBulkDismissVulnerabilities200 =
  AppResponseSerialization & {
    data?: VulnerabilityDismissal[];
  };

export type ToolsControllerGetManyToolsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  type?: ToolsControllerGetManyToolsType;
  category?: ToolsControllerGetManyToolsCategory;
  workspaceId?: string;
  providerId?: string;
};

export type ToolsControllerGetManyToolsType =
  (typeof ToolsControllerGetManyToolsType)[keyof typeof ToolsControllerGetManyToolsType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolsControllerGetManyToolsType = {
  built_in: 'built_in',
  provider: 'provider',
} as const;

export type ToolsControllerGetManyToolsCategory =
  (typeof ToolsControllerGetManyToolsCategory)[keyof typeof ToolsControllerGetManyToolsCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolsControllerGetManyToolsCategory = {
  subdomains: 'subdomains',
  http_probe: 'http_probe',
  ports_scanner: 'ports_scanner',
  vulnerabilities: 'vulnerabilities',
  classifier: 'classifier',
  assistant: 'assistant',
} as const;

export type ToolsControllerGetInstalledToolsParams = {
  category?: ToolsControllerGetInstalledToolsCategory;
};

export type ToolsControllerGetInstalledToolsCategory =
  (typeof ToolsControllerGetInstalledToolsCategory)[keyof typeof ToolsControllerGetInstalledToolsCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolsControllerGetInstalledToolsCategory = {
  subdomains: 'subdomains',
  http_probe: 'http_probe',
  ports_scanner: 'ports_scanner',
  vulnerabilities: 'vulnerabilities',
  classifier: 'classifier',
  assistant: 'assistant',
} as const;

export type ProvidersControllerGetManyProvidersParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  name?: string;
};

export type TemplatesControllerGetAllTemplatesParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  value?: string;
};

export type AssetGroupControllerGetAllParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  targetIds?: string[];
};

export type AssetGroupControllerGetAssetsByAssetGroupsIdParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type AssetGroupControllerGetWorkflowsByAssetGroupsIdParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type AssetGroupControllerGetAssetsNotInAssetGroupParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type AssetGroupControllerGetWorkflowsNotInAssetGroupParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type IssuesControllerGetManyParams = {
  /**
   * Search term for filtering issues
   */
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
  /**
   * Filter by status
   */
  status?: IssuesControllerGetManyStatusItem[];
};

export type IssuesControllerGetManyStatusItem =
  (typeof IssuesControllerGetManyStatusItem)[keyof typeof IssuesControllerGetManyStatusItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IssuesControllerGetManyStatusItem = {
  open: 'open',
  closed: 'closed',
} as const;

export type IssuesControllerGetCommentsByIssueIdParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type NotificationsControllerGetNotificationsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

export type StorageControllerUploadFileBody = {
  file: Blob;
  /** Bucket name (default: "default") */
  bucket?: string;
};

export type StorageControllerUploadFile200 = {
  path?: string;
  bucket?: string;
  fullPath?: string;
};

export type StorageControllerForwardImageParams = {
  /**
   * The URL of the image to forward
   */
  url: string;
};

export type McpControllerGetMcpPermissionsParams = {
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Registers a new security testing target such as a domain, IP address, or network range for vulnerability assessment and continuous monitoring.
 * @summary Create a target
 */
export const targetsControllerCreateTarget = (
  createTargetDto: CreateTargetDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Target>(
    {
      url: `/api/targets`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createTargetDto,
      signal,
    },
    options,
  );
};

export const getTargetsControllerCreateTargetMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof targetsControllerCreateTarget>>,
    TError,
    { data: CreateTargetDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof targetsControllerCreateTarget>>,
  TError,
  { data: CreateTargetDto },
  TContext
> => {
  const mutationKey = ['targetsControllerCreateTarget'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof targetsControllerCreateTarget>>,
    { data: CreateTargetDto }
  > = (props) => {
    const { data } = props ?? {};

    return targetsControllerCreateTarget(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TargetsControllerCreateTargetMutationResult = NonNullable<
  Awaited<ReturnType<typeof targetsControllerCreateTarget>>
>;
export type TargetsControllerCreateTargetMutationBody = CreateTargetDto;
export type TargetsControllerCreateTargetMutationError = unknown;

/**
 * @summary Create a target
 */
export const useTargetsControllerCreateTarget = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof targetsControllerCreateTarget>>,
      TError,
      { data: CreateTargetDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof targetsControllerCreateTarget>>,
  TError,
  { data: CreateTargetDto },
  TContext
> => {
  const mutationOptions =
    getTargetsControllerCreateTargetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Fetches a comprehensive list of all registered security testing targets within the specified workspace for vulnerability management and assessment tracking.
 * @summary Get all targets in a workspace
 */
export const targetsControllerGetTargetsInWorkspace = (
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetManyTargetResponseDtoDto>(
    { url: `/api/targets`, method: 'GET', params, signal },
    options,
  );
};

export const getTargetsControllerGetTargetsInWorkspaceInfiniteQueryKey = (
  params?: TargetsControllerGetTargetsInWorkspaceParams,
) => {
  return ['infinite', `/api/targets`, ...(params ? [params] : [])] as const;
};

export const getTargetsControllerGetTargetsInWorkspaceQueryKey = (
  params?: TargetsControllerGetTargetsInWorkspaceParams,
) => {
  return [`/api/targets`, ...(params ? [params] : [])] as const;
};

export const getTargetsControllerGetTargetsInWorkspaceInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        TargetsControllerGetTargetsInWorkspaceParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTargetsControllerGetTargetsInWorkspaceInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    QueryKey,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  > = ({ signal, pageParam }) =>
    targetsControllerGetTargetsInWorkspace(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TError,
    TData,
    QueryKey,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TargetsControllerGetTargetsInWorkspaceInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>
  >;
export type TargetsControllerGetTargetsInWorkspaceInfiniteQueryError = unknown;

export function useTargetsControllerGetTargetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params: undefined | TargetsControllerGetTargetsInWorkspaceParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        TargetsControllerGetTargetsInWorkspaceParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerGetTargetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        TargetsControllerGetTargetsInWorkspaceParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerGetTargetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        TargetsControllerGetTargetsInWorkspaceParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all targets in a workspace
 */

export function useTargetsControllerGetTargetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TargetsControllerGetTargetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        TargetsControllerGetTargetsInWorkspaceParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getTargetsControllerGetTargetsInWorkspaceInfiniteQueryOptions(
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTargetsControllerGetTargetsInWorkspaceQueryOptions = <
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTargetsControllerGetTargetsInWorkspaceQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>
  > = ({ signal }) =>
    targetsControllerGetTargetsInWorkspace(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TargetsControllerGetTargetsInWorkspaceQueryResult = NonNullable<
  Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>
>;
export type TargetsControllerGetTargetsInWorkspaceQueryError = unknown;

export function useTargetsControllerGetTargetsInWorkspace<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
  TError = unknown,
>(
  params: undefined | TargetsControllerGetTargetsInWorkspaceParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerGetTargetsInWorkspace<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerGetTargetsInWorkspace<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all targets in a workspace
 */

export function useTargetsControllerGetTargetsInWorkspace<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
  TError = unknown,
>(
  params?: TargetsControllerGetTargetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetsInWorkspace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTargetsControllerGetTargetsInWorkspaceQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Exports all targets in a workspace to a CSV file containing value, last discovered date, and creation date for reporting and analysis purposes.
 * @summary Export targets to CSV
 */
export const targetsControllerExportTargetsToCSV = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/targets/export`, method: 'GET', signal },
    options,
  );
};

export const getTargetsControllerExportTargetsToCSVQueryKey = () => {
  return [`/api/targets/export`] as const;
};

export const getTargetsControllerExportTargetsToCSVQueryOptions = <
  TData = Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTargetsControllerExportTargetsToCSVQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>
  > = ({ signal }) =>
    targetsControllerExportTargetsToCSV(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TargetsControllerExportTargetsToCSVQueryResult = NonNullable<
  Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>
>;
export type TargetsControllerExportTargetsToCSVQueryError = unknown;

export function useTargetsControllerExportTargetsToCSV<
  TData = Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerExportTargetsToCSV<
  TData = Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerExportTargetsToCSV<
  TData = Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Export targets to CSV
 */

export function useTargetsControllerExportTargetsToCSV<
  TData = Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerExportTargetsToCSV>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getTargetsControllerExportTargetsToCSVQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetches detailed information about a specific security testing target using its unique identifier, including configuration and assessment status.
 * @summary Get a target by ID
 */
export const targetsControllerGetTargetById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Target>(
    { url: `/api/targets/${id}`, method: 'GET', signal },
    options,
  );
};

export const getTargetsControllerGetTargetByIdQueryKey = (id?: string) => {
  return [`/api/targets/${id}`] as const;
};

export const getTargetsControllerGetTargetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTargetsControllerGetTargetByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof targetsControllerGetTargetById>>
  > = ({ signal }) =>
    targetsControllerGetTargetById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TargetsControllerGetTargetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof targetsControllerGetTargetById>>
>;
export type TargetsControllerGetTargetByIdQueryError = unknown;

export function useTargetsControllerGetTargetById<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerGetTargetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerGetTargetById<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
          TError,
          Awaited<ReturnType<typeof targetsControllerGetTargetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTargetsControllerGetTargetById<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a target by ID
 */

export function useTargetsControllerGetTargetById<
  TData = Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof targetsControllerGetTargetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTargetsControllerGetTargetByIdQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Modifies the configuration and properties of an existing security testing target, allowing for dynamic adjustments to assessment parameters.
 * @summary Update a target
 */
export const targetsControllerUpdateTarget = (
  id: string,
  updateTargetDto: UpdateTargetDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<Target>(
    {
      url: `/api/targets/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateTargetDto,
    },
    options,
  );
};

export const getTargetsControllerUpdateTargetMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof targetsControllerUpdateTarget>>,
    TError,
    { id: string; data: UpdateTargetDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof targetsControllerUpdateTarget>>,
  TError,
  { id: string; data: UpdateTargetDto },
  TContext
> => {
  const mutationKey = ['targetsControllerUpdateTarget'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof targetsControllerUpdateTarget>>,
    { id: string; data: UpdateTargetDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return targetsControllerUpdateTarget(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TargetsControllerUpdateTargetMutationResult = NonNullable<
  Awaited<ReturnType<typeof targetsControllerUpdateTarget>>
>;
export type TargetsControllerUpdateTargetMutationBody = UpdateTargetDto;
export type TargetsControllerUpdateTargetMutationError = unknown;

/**
 * @summary Update a target
 */
export const useTargetsControllerUpdateTarget = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof targetsControllerUpdateTarget>>,
      TError,
      { id: string; data: UpdateTargetDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof targetsControllerUpdateTarget>>,
  TError,
  { id: string; data: UpdateTargetDto },
  TContext
> => {
  const mutationOptions =
    getTargetsControllerUpdateTargetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Removes a security testing target from the specified workspace, terminating all associated monitoring and assessment activities.
 * @summary Delete a target from a workspace
 */
export const targetsControllerDeleteTargetFromWorkspace = (
  id: string,
  workspaceId: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/targets/${id}/workspace/${workspaceId}`, method: 'DELETE' },
    options,
  );
};

export const getTargetsControllerDeleteTargetFromWorkspaceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof targetsControllerDeleteTargetFromWorkspace>>,
    TError,
    { id: string; workspaceId: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof targetsControllerDeleteTargetFromWorkspace>>,
  TError,
  { id: string; workspaceId: string },
  TContext
> => {
  const mutationKey = ['targetsControllerDeleteTargetFromWorkspace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof targetsControllerDeleteTargetFromWorkspace>>,
    { id: string; workspaceId: string }
  > = (props) => {
    const { id, workspaceId } = props ?? {};

    return targetsControllerDeleteTargetFromWorkspace(
      id,
      workspaceId,
      requestOptions,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type TargetsControllerDeleteTargetFromWorkspaceMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof targetsControllerDeleteTargetFromWorkspace>>
  >;

export type TargetsControllerDeleteTargetFromWorkspaceMutationError = unknown;

/**
 * @summary Delete a target from a workspace
 */
export const useTargetsControllerDeleteTargetFromWorkspace = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof targetsControllerDeleteTargetFromWorkspace>>,
      TError,
      { id: string; workspaceId: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof targetsControllerDeleteTargetFromWorkspace>>,
  TError,
  { id: string; workspaceId: string },
  TContext
> => {
  const mutationOptions =
    getTargetsControllerDeleteTargetFromWorkspaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates a comprehensive security re-assessment of the specified target, triggering new vulnerability scans to identify potential security risks.
 * @summary Rescan a target
 */
export const targetsControllerReScanTarget = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/targets/${id}/re-scan`, method: 'POST', signal },
    options,
  );
};

export const getTargetsControllerReScanTargetMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof targetsControllerReScanTarget>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof targetsControllerReScanTarget>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['targetsControllerReScanTarget'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof targetsControllerReScanTarget>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return targetsControllerReScanTarget(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TargetsControllerReScanTargetMutationResult = NonNullable<
  Awaited<ReturnType<typeof targetsControllerReScanTarget>>
>;

export type TargetsControllerReScanTargetMutationError = unknown;

/**
 * @summary Rescan a target
 */
export const useTargetsControllerReScanTarget = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof targetsControllerReScanTarget>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof targetsControllerReScanTarget>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getTargetsControllerReScanTargetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Establishes a new isolated security workspace for organizing and managing assets, targets, and vulnerabilities within a dedicated environment.
 * @summary Create Workspace
 */
export const workspacesControllerCreateWorkspace = (
  createWorkspaceDto: CreateWorkspaceDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Workspace>(
    {
      url: `/api/workspaces`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createWorkspaceDto,
      signal,
    },
    options,
  );
};

export const getWorkspacesControllerCreateWorkspaceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workspacesControllerCreateWorkspace>>,
    TError,
    { data: CreateWorkspaceDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workspacesControllerCreateWorkspace>>,
  TError,
  { data: CreateWorkspaceDto },
  TContext
> => {
  const mutationKey = ['workspacesControllerCreateWorkspace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workspacesControllerCreateWorkspace>>,
    { data: CreateWorkspaceDto }
  > = (props) => {
    const { data } = props ?? {};

    return workspacesControllerCreateWorkspace(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkspacesControllerCreateWorkspaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerCreateWorkspace>>
>;
export type WorkspacesControllerCreateWorkspaceMutationBody =
  CreateWorkspaceDto;
export type WorkspacesControllerCreateWorkspaceMutationError = unknown;

/**
 * @summary Create Workspace
 */
export const useWorkspacesControllerCreateWorkspace = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workspacesControllerCreateWorkspace>>,
      TError,
      { data: CreateWorkspaceDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workspacesControllerCreateWorkspace>>,
  TError,
  { data: CreateWorkspaceDto },
  TContext
> => {
  const mutationOptions =
    getWorkspacesControllerCreateWorkspaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Fetches a comprehensive list of security workspaces that the authenticated user has access to, providing multi-tenant organization capabilities.
 * @summary Get Workspaces
 */
export const workspacesControllerGetWorkspaces = (
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyWorkspaceDto>(
    { url: `/api/workspaces`, method: 'GET', params, signal },
    options,
  );
};

export const getWorkspacesControllerGetWorkspacesInfiniteQueryKey = (
  params?: WorkspacesControllerGetWorkspacesParams,
) => {
  return ['infinite', `/api/workspaces`, ...(params ? [params] : [])] as const;
};

export const getWorkspacesControllerGetWorkspacesQueryKey = (
  params?: WorkspacesControllerGetWorkspacesParams,
) => {
  return [`/api/workspaces`, ...(params ? [params] : [])] as const;
};

export const getWorkspacesControllerGetWorkspacesInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    WorkspacesControllerGetWorkspacesParams['page']
  >,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData,
        QueryKey,
        WorkspacesControllerGetWorkspacesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkspacesControllerGetWorkspacesInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    QueryKey,
    WorkspacesControllerGetWorkspacesParams['page']
  > = ({ signal, pageParam }) =>
    workspacesControllerGetWorkspaces(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    TError,
    TData,
    QueryKey,
    WorkspacesControllerGetWorkspacesParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkspacesControllerGetWorkspacesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>
>;
export type WorkspacesControllerGetWorkspacesInfiniteQueryError = unknown;

export function useWorkspacesControllerGetWorkspacesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    WorkspacesControllerGetWorkspacesParams['page']
  >,
  TError = unknown,
>(
  params: undefined | WorkspacesControllerGetWorkspacesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData,
        QueryKey,
        WorkspacesControllerGetWorkspacesParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspacesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    WorkspacesControllerGetWorkspacesParams['page']
  >,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData,
        QueryKey,
        WorkspacesControllerGetWorkspacesParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspacesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    WorkspacesControllerGetWorkspacesParams['page']
  >,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData,
        QueryKey,
        WorkspacesControllerGetWorkspacesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Workspaces
 */

export function useWorkspacesControllerGetWorkspacesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    WorkspacesControllerGetWorkspacesParams['page']
  >,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData,
        QueryKey,
        WorkspacesControllerGetWorkspacesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkspacesControllerGetWorkspacesInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getWorkspacesControllerGetWorkspacesQueryOptions = <
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkspacesControllerGetWorkspacesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>
  > = ({ signal }) =>
    workspacesControllerGetWorkspaces(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkspacesControllerGetWorkspacesQueryResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>
>;
export type WorkspacesControllerGetWorkspacesQueryError = unknown;

export function useWorkspacesControllerGetWorkspaces<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
  TError = unknown,
>(
  params: undefined | WorkspacesControllerGetWorkspacesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaces<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaces<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Workspaces
 */

export function useWorkspacesControllerGetWorkspaces<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
  TError = unknown,
>(
  params?: WorkspacesControllerGetWorkspacesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaces>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkspacesControllerGetWorkspacesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the authentication API key for secure access to the specified workspace, enabling programmatic interactions with workspace resources.
 * @summary Get workspace API key
 */
export const workspacesControllerGetWorkspaceApiKey = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetApiKeyResponseDto>(
    { url: `/api/workspaces/api-key`, method: 'GET', signal },
    options,
  );
};

export const getWorkspacesControllerGetWorkspaceApiKeyQueryKey = () => {
  return [`/api/workspaces/api-key`] as const;
};

export const getWorkspacesControllerGetWorkspaceApiKeyQueryOptions = <
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkspacesControllerGetWorkspaceApiKeyQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>
  > = ({ signal }) =>
    workspacesControllerGetWorkspaceApiKey(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkspacesControllerGetWorkspaceApiKeyQueryResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>
>;
export type WorkspacesControllerGetWorkspaceApiKeyQueryError = unknown;

export function useWorkspacesControllerGetWorkspaceApiKey<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaceApiKey<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaceApiKey<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workspace API key
 */

export function useWorkspacesControllerGetWorkspaceApiKey<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getWorkspacesControllerGetWorkspaceApiKeyQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the configuration settings for a specified workspace, including asset discovery and auto-enablement settings.
 * @summary Get workspace configs
 */
export const workspacesControllerGetWorkspaceConfigs = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetWorkspaceConfigsDto>(
    { url: `/api/workspaces/configs`, method: 'GET', signal },
    options,
  );
};

export const getWorkspacesControllerGetWorkspaceConfigsQueryKey = () => {
  return [`/api/workspaces/configs`] as const;
};

export const getWorkspacesControllerGetWorkspaceConfigsQueryOptions = <
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkspacesControllerGetWorkspaceConfigsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>
  > = ({ signal }) =>
    workspacesControllerGetWorkspaceConfigs(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkspacesControllerGetWorkspaceConfigsQueryResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>
>;
export type WorkspacesControllerGetWorkspaceConfigsQueryError = unknown;

export function useWorkspacesControllerGetWorkspaceConfigs<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaceConfigs<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaceConfigs<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workspace configs
 */

export function useWorkspacesControllerGetWorkspaceConfigs<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceConfigs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getWorkspacesControllerGetWorkspaceConfigsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates the configuration settings for a specified workspace, including asset discovery and auto-enablement options.
 * @summary Update workspace configs
 */
export const workspacesControllerUpdateWorkspaceConfigs = (
  updateWorkspaceConfigsDto: UpdateWorkspaceConfigsDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/workspaces/configs`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateWorkspaceConfigsDto,
    },
    options,
  );
};

export const getWorkspacesControllerUpdateWorkspaceConfigsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workspacesControllerUpdateWorkspaceConfigs>>,
    TError,
    { data: UpdateWorkspaceConfigsDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workspacesControllerUpdateWorkspaceConfigs>>,
  TError,
  { data: UpdateWorkspaceConfigsDto },
  TContext
> => {
  const mutationKey = ['workspacesControllerUpdateWorkspaceConfigs'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workspacesControllerUpdateWorkspaceConfigs>>,
    { data: UpdateWorkspaceConfigsDto }
  > = (props) => {
    const { data } = props ?? {};

    return workspacesControllerUpdateWorkspaceConfigs(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkspacesControllerUpdateWorkspaceConfigsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof workspacesControllerUpdateWorkspaceConfigs>>
  >;
export type WorkspacesControllerUpdateWorkspaceConfigsMutationBody =
  UpdateWorkspaceConfigsDto;
export type WorkspacesControllerUpdateWorkspaceConfigsMutationError = unknown;

/**
 * @summary Update workspace configs
 */
export const useWorkspacesControllerUpdateWorkspaceConfigs = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workspacesControllerUpdateWorkspaceConfigs>>,
      TError,
      { data: UpdateWorkspaceConfigsDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workspacesControllerUpdateWorkspaceConfigs>>,
  TError,
  { data: UpdateWorkspaceConfigsDto },
  TContext
> => {
  const mutationOptions =
    getWorkspacesControllerUpdateWorkspaceConfigsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Fetches detailed information about a specific security workspace using its unique identifier, including all associated metadata and configuration.
 * @summary Get Workspace By ID
 */
export const workspacesControllerGetWorkspaceById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Workspace>(
    { url: `/api/workspaces/${id}`, method: 'GET', signal },
    options,
  );
};

export const getWorkspacesControllerGetWorkspaceByIdQueryKey = (
  id?: string,
) => {
  return [`/api/workspaces/${id}`] as const;
};

export const getWorkspacesControllerGetWorkspaceByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkspacesControllerGetWorkspaceByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>
  > = ({ signal }) =>
    workspacesControllerGetWorkspaceById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkspacesControllerGetWorkspaceByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>
>;
export type WorkspacesControllerGetWorkspaceByIdQueryError = unknown;

export function useWorkspacesControllerGetWorkspaceById<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaceById<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
          TError,
          Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkspacesControllerGetWorkspaceById<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Workspace By ID
 */

export function useWorkspacesControllerGetWorkspaceById<
  TData = Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workspacesControllerGetWorkspaceById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkspacesControllerGetWorkspaceByIdQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Modifies the configuration and metadata of an existing security workspace, allowing for dynamic adjustments to workspace settings and properties.
 * @summary Update Workspace
 */
export const workspacesControllerUpdateWorkspace = (
  id: string,
  updateWorkspaceDto: UpdateWorkspaceDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/workspaces/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateWorkspaceDto,
    },
    options,
  );
};

export const getWorkspacesControllerUpdateWorkspaceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workspacesControllerUpdateWorkspace>>,
    TError,
    { id: string; data: UpdateWorkspaceDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workspacesControllerUpdateWorkspace>>,
  TError,
  { id: string; data: UpdateWorkspaceDto },
  TContext
> => {
  const mutationKey = ['workspacesControllerUpdateWorkspace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workspacesControllerUpdateWorkspace>>,
    { id: string; data: UpdateWorkspaceDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return workspacesControllerUpdateWorkspace(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkspacesControllerUpdateWorkspaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerUpdateWorkspace>>
>;
export type WorkspacesControllerUpdateWorkspaceMutationBody =
  UpdateWorkspaceDto;
export type WorkspacesControllerUpdateWorkspaceMutationError = unknown;

/**
 * @summary Update Workspace
 */
export const useWorkspacesControllerUpdateWorkspace = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workspacesControllerUpdateWorkspace>>,
      TError,
      { id: string; data: UpdateWorkspaceDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workspacesControllerUpdateWorkspace>>,
  TError,
  { id: string; data: UpdateWorkspaceDto },
  TContext
> => {
  const mutationOptions =
    getWorkspacesControllerUpdateWorkspaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Permanently removes a security workspace and all its associated data, including assets, targets, vulnerabilities, and configurations.
 * @summary Delete Workspace
 */
export const workspacesControllerDeleteWorkspace = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/workspaces/${id}`, method: 'DELETE' },
    options,
  );
};

export const getWorkspacesControllerDeleteWorkspaceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workspacesControllerDeleteWorkspace>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workspacesControllerDeleteWorkspace>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['workspacesControllerDeleteWorkspace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workspacesControllerDeleteWorkspace>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return workspacesControllerDeleteWorkspace(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkspacesControllerDeleteWorkspaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerDeleteWorkspace>>
>;

export type WorkspacesControllerDeleteWorkspaceMutationError = unknown;

/**
 * @summary Delete Workspace
 */
export const useWorkspacesControllerDeleteWorkspace = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workspacesControllerDeleteWorkspace>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workspacesControllerDeleteWorkspace>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getWorkspacesControllerDeleteWorkspaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Generates a new API key for the specified workspace, invalidating the previous key to enhance security and maintain authorized access.
 * @summary Rotate API key
 */
export const workspacesControllerRotateApiKey = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetApiKeyResponseDto>(
    { url: `/api/workspaces/${id}/api-key/rotate`, method: 'POST', signal },
    options,
  );
};

export const getWorkspacesControllerRotateApiKeyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workspacesControllerRotateApiKey>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workspacesControllerRotateApiKey>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['workspacesControllerRotateApiKey'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workspacesControllerRotateApiKey>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return workspacesControllerRotateApiKey(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkspacesControllerRotateApiKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerRotateApiKey>>
>;

export type WorkspacesControllerRotateApiKeyMutationError = unknown;

/**
 * @summary Rotate API key
 */
export const useWorkspacesControllerRotateApiKey = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workspacesControllerRotateApiKey>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workspacesControllerRotateApiKey>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getWorkspacesControllerRotateApiKeyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Changes the archival status of a workspace, allowing for temporary deactivation or reactivation of workspace resources without permanent deletion.
 * @summary Archive/Unarchive Workspace
 */
export const workspacesControllerMakeArchived = (
  id: string,
  archiveWorkspaceDto: ArchiveWorkspaceDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/workspaces/${id}/archived`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: archiveWorkspaceDto,
    },
    options,
  );
};

export const getWorkspacesControllerMakeArchivedMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workspacesControllerMakeArchived>>,
    TError,
    { id: string; data: ArchiveWorkspaceDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workspacesControllerMakeArchived>>,
  TError,
  { id: string; data: ArchiveWorkspaceDto },
  TContext
> => {
  const mutationKey = ['workspacesControllerMakeArchived'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workspacesControllerMakeArchived>>,
    { id: string; data: ArchiveWorkspaceDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return workspacesControllerMakeArchived(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkspacesControllerMakeArchivedMutationResult = NonNullable<
  Awaited<ReturnType<typeof workspacesControllerMakeArchived>>
>;
export type WorkspacesControllerMakeArchivedMutationBody = ArchiveWorkspaceDto;
export type WorkspacesControllerMakeArchivedMutationError = unknown;

/**
 * @summary Archive/Unarchive Workspace
 */
export const useWorkspacesControllerMakeArchived = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workspacesControllerMakeArchived>>,
      TError,
      { id: string; data: ArchiveWorkspaceDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workspacesControllerMakeArchived>>,
  TError,
  { id: string; data: ArchiveWorkspaceDto },
  TContext
> => {
  const mutationOptions =
    getWorkspacesControllerMakeArchivedMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a list of all available workflow templates in YAML format.
 * @summary Get all workflow templates
 */
export const workflowsControllerListTemplates = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyStringDto>(
    { url: `/api/workflows/templates`, method: 'GET', signal },
    options,
  );
};

export const getWorkflowsControllerListTemplatesQueryKey = () => {
  return [`/api/workflows/templates`] as const;
};

export const getWorkflowsControllerListTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getWorkflowsControllerListTemplatesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workflowsControllerListTemplates>>
  > = ({ signal }) => workflowsControllerListTemplates(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkflowsControllerListTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof workflowsControllerListTemplates>>
>;
export type WorkflowsControllerListTemplatesQueryError = unknown;

export function useWorkflowsControllerListTemplates<
  TData = Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerListTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerListTemplates<
  TData = Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerListTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerListTemplates<
  TData = Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all workflow templates
 */

export function useWorkflowsControllerListTemplates<
  TData = Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerListTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkflowsControllerListTemplatesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a paginated list of workflows within the specified workspace. Supports filtering by name.
 * @summary Get many workflows
 */
export const workflowsControllerGetManyWorkflows = (
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetManyWorkflowsResponseDtoDto>(
    { url: `/api/workflows`, method: 'GET', params, signal },
    options,
  );
};

export const getWorkflowsControllerGetManyWorkflowsInfiniteQueryKey = (
  params?: WorkflowsControllerGetManyWorkflowsParams,
) => {
  return ['infinite', `/api/workflows`, ...(params ? [params] : [])] as const;
};

export const getWorkflowsControllerGetManyWorkflowsQueryKey = (
  params?: WorkflowsControllerGetManyWorkflowsParams,
) => {
  return [`/api/workflows`, ...(params ? [params] : [])] as const;
};

export const getWorkflowsControllerGetManyWorkflowsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    WorkflowsControllerGetManyWorkflowsParams['page']
  >,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData,
        QueryKey,
        WorkflowsControllerGetManyWorkflowsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkflowsControllerGetManyWorkflowsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    QueryKey,
    WorkflowsControllerGetManyWorkflowsParams['page']
  > = ({ signal, pageParam }) =>
    workflowsControllerGetManyWorkflows(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    TError,
    TData,
    QueryKey,
    WorkflowsControllerGetManyWorkflowsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkflowsControllerGetManyWorkflowsInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>>;
export type WorkflowsControllerGetManyWorkflowsInfiniteQueryError = unknown;

export function useWorkflowsControllerGetManyWorkflowsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    WorkflowsControllerGetManyWorkflowsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | WorkflowsControllerGetManyWorkflowsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData,
        QueryKey,
        WorkflowsControllerGetManyWorkflowsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerGetManyWorkflowsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    WorkflowsControllerGetManyWorkflowsParams['page']
  >,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData,
        QueryKey,
        WorkflowsControllerGetManyWorkflowsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerGetManyWorkflowsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    WorkflowsControllerGetManyWorkflowsParams['page']
  >,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData,
        QueryKey,
        WorkflowsControllerGetManyWorkflowsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get many workflows
 */

export function useWorkflowsControllerGetManyWorkflowsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    WorkflowsControllerGetManyWorkflowsParams['page']
  >,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData,
        QueryKey,
        WorkflowsControllerGetManyWorkflowsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getWorkflowsControllerGetManyWorkflowsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getWorkflowsControllerGetManyWorkflowsQueryOptions = <
  TData = Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkflowsControllerGetManyWorkflowsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>
  > = ({ signal }) =>
    workflowsControllerGetManyWorkflows(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkflowsControllerGetManyWorkflowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>
>;
export type WorkflowsControllerGetManyWorkflowsQueryError = unknown;

export function useWorkflowsControllerGetManyWorkflows<
  TData = Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
  TError = unknown,
>(
  params: undefined | WorkflowsControllerGetManyWorkflowsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerGetManyWorkflows<
  TData = Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerGetManyWorkflows<
  TData = Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get many workflows
 */

export function useWorkflowsControllerGetManyWorkflows<
  TData = Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
  TError = unknown,
>(
  params?: WorkflowsControllerGetManyWorkflowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetManyWorkflows>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkflowsControllerGetManyWorkflowsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new workflow with the provided data.
 * @summary Create workflow
 */
export const workflowsControllerCreateWorkflow = (
  createWorkflowDto: CreateWorkflowDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Workflow>(
    {
      url: `/api/workflows`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createWorkflowDto,
      signal,
    },
    options,
  );
};

export const getWorkflowsControllerCreateWorkflowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workflowsControllerCreateWorkflow>>,
    TError,
    { data: CreateWorkflowDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workflowsControllerCreateWorkflow>>,
  TError,
  { data: CreateWorkflowDto },
  TContext
> => {
  const mutationKey = ['workflowsControllerCreateWorkflow'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workflowsControllerCreateWorkflow>>,
    { data: CreateWorkflowDto }
  > = (props) => {
    const { data } = props ?? {};

    return workflowsControllerCreateWorkflow(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkflowsControllerCreateWorkflowMutationResult = NonNullable<
  Awaited<ReturnType<typeof workflowsControllerCreateWorkflow>>
>;
export type WorkflowsControllerCreateWorkflowMutationBody = CreateWorkflowDto;
export type WorkflowsControllerCreateWorkflowMutationError = unknown;

/**
 * @summary Create workflow
 */
export const useWorkflowsControllerCreateWorkflow = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workflowsControllerCreateWorkflow>>,
      TError,
      { data: CreateWorkflowDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workflowsControllerCreateWorkflow>>,
  TError,
  { data: CreateWorkflowDto },
  TContext
> => {
  const mutationOptions =
    getWorkflowsControllerCreateWorkflowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a specific workflow by its ID within the specified workspace.
 * @summary Get workflow by ID
 */
export const workflowsControllerGetWorkspaceWorkflow = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Workflow>(
    { url: `/api/workflows/${id}`, method: 'GET', signal },
    options,
  );
};

export const getWorkflowsControllerGetWorkspaceWorkflowQueryKey = (
  id?: string,
) => {
  return [`/api/workflows/${id}`] as const;
};

export const getWorkflowsControllerGetWorkspaceWorkflowQueryOptions = <
  TData = Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkflowsControllerGetWorkspaceWorkflowQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>
  > = ({ signal }) =>
    workflowsControllerGetWorkspaceWorkflow(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkflowsControllerGetWorkspaceWorkflowQueryResult = NonNullable<
  Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>
>;
export type WorkflowsControllerGetWorkspaceWorkflowQueryError = unknown;

export function useWorkflowsControllerGetWorkspaceWorkflow<
  TData = Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerGetWorkspaceWorkflow<
  TData = Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
          TError,
          Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkflowsControllerGetWorkspaceWorkflow<
  TData = Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workflow by ID
 */

export function useWorkflowsControllerGetWorkspaceWorkflow<
  TData = Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workflowsControllerGetWorkspaceWorkflow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkflowsControllerGetWorkspaceWorkflowQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an existing workflow with the provided data.
 * @summary Update workflow
 */
export const workflowsControllerUpdateWorkflow = (
  id: string,
  updateWorkflowDto: UpdateWorkflowDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<Workflow>(
    {
      url: `/api/workflows/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateWorkflowDto,
    },
    options,
  );
};

export const getWorkflowsControllerUpdateWorkflowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workflowsControllerUpdateWorkflow>>,
    TError,
    { id: string; data: UpdateWorkflowDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workflowsControllerUpdateWorkflow>>,
  TError,
  { id: string; data: UpdateWorkflowDto },
  TContext
> => {
  const mutationKey = ['workflowsControllerUpdateWorkflow'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workflowsControllerUpdateWorkflow>>,
    { id: string; data: UpdateWorkflowDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return workflowsControllerUpdateWorkflow(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkflowsControllerUpdateWorkflowMutationResult = NonNullable<
  Awaited<ReturnType<typeof workflowsControllerUpdateWorkflow>>
>;
export type WorkflowsControllerUpdateWorkflowMutationBody = UpdateWorkflowDto;
export type WorkflowsControllerUpdateWorkflowMutationError = unknown;

/**
 * @summary Update workflow
 */
export const useWorkflowsControllerUpdateWorkflow = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workflowsControllerUpdateWorkflow>>,
      TError,
      { id: string; data: UpdateWorkflowDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workflowsControllerUpdateWorkflow>>,
  TError,
  { id: string; data: UpdateWorkflowDto },
  TContext
> => {
  const mutationOptions =
    getWorkflowsControllerUpdateWorkflowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a workflow by its ID.
 * @summary Delete workflow
 */
export const workflowsControllerDeleteWorkflow = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/workflows/${id}`, method: 'DELETE' },
    options,
  );
};

export const getWorkflowsControllerDeleteWorkflowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workflowsControllerDeleteWorkflow>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workflowsControllerDeleteWorkflow>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['workflowsControllerDeleteWorkflow'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workflowsControllerDeleteWorkflow>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return workflowsControllerDeleteWorkflow(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkflowsControllerDeleteWorkflowMutationResult = NonNullable<
  Awaited<ReturnType<typeof workflowsControllerDeleteWorkflow>>
>;

export type WorkflowsControllerDeleteWorkflowMutationError = unknown;

/**
 * @summary Delete workflow
 */
export const useWorkflowsControllerDeleteWorkflow = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workflowsControllerDeleteWorkflow>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workflowsControllerDeleteWorkflow>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getWorkflowsControllerDeleteWorkflowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const rootControllerGetHealth = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<void>(
    { url: `/api/health`, method: 'GET', signal },
    options,
  );
};

export const getRootControllerGetHealthQueryKey = () => {
  return [`/api/health`] as const;
};

export const getRootControllerGetHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof rootControllerGetHealth>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof rootControllerGetHealth>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRootControllerGetHealthQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof rootControllerGetHealth>>
  > = ({ signal }) => rootControllerGetHealth(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof rootControllerGetHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RootControllerGetHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof rootControllerGetHealth>>
>;
export type RootControllerGetHealthQueryError = unknown;

export function useRootControllerGetHealth<
  TData = Awaited<ReturnType<typeof rootControllerGetHealth>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetHealth>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootControllerGetHealth>>,
          TError,
          Awaited<ReturnType<typeof rootControllerGetHealth>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootControllerGetHealth<
  TData = Awaited<ReturnType<typeof rootControllerGetHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetHealth>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootControllerGetHealth>>,
          TError,
          Awaited<ReturnType<typeof rootControllerGetHealth>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootControllerGetHealth<
  TData = Awaited<ReturnType<typeof rootControllerGetHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetHealth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useRootControllerGetHealth<
  TData = Awaited<ReturnType<typeof rootControllerGetHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetHealth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRootControllerGetHealthQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates the first admin user in the system.
 * @summary Creates the first admin user in the system.
 */
export const rootControllerCreateFirstAdmin = (
  createFirstAdminDto: CreateFirstAdminDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/init-admin`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createFirstAdminDto,
      signal,
    },
    options,
  );
};

export const getRootControllerCreateFirstAdminMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rootControllerCreateFirstAdmin>>,
    TError,
    { data: CreateFirstAdminDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rootControllerCreateFirstAdmin>>,
  TError,
  { data: CreateFirstAdminDto },
  TContext
> => {
  const mutationKey = ['rootControllerCreateFirstAdmin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rootControllerCreateFirstAdmin>>,
    { data: CreateFirstAdminDto }
  > = (props) => {
    const { data } = props ?? {};

    return rootControllerCreateFirstAdmin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RootControllerCreateFirstAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof rootControllerCreateFirstAdmin>>
>;
export type RootControllerCreateFirstAdminMutationBody = CreateFirstAdminDto;
export type RootControllerCreateFirstAdminMutationError = unknown;

/**
 * @summary Creates the first admin user in the system.
 */
export const useRootControllerCreateFirstAdmin = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rootControllerCreateFirstAdmin>>,
      TError,
      { data: CreateFirstAdminDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof rootControllerCreateFirstAdmin>>,
  TError,
  { data: CreateFirstAdminDto },
  TContext
> => {
  const mutationOptions =
    getRootControllerCreateFirstAdminMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns metadata about the system state, like whether it has been initialized.
 * @summary Get system metadata.
 */
export const rootControllerGetMetadata = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetMetadataDto>(
    { url: `/api/metadata`, method: 'GET', signal },
    options,
  );
};

export const getRootControllerGetMetadataQueryKey = () => {
  return [`/api/metadata`] as const;
};

export const getRootControllerGetMetadataQueryOptions = <
  TData = Awaited<ReturnType<typeof rootControllerGetMetadata>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof rootControllerGetMetadata>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRootControllerGetMetadataQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof rootControllerGetMetadata>>
  > = ({ signal }) => rootControllerGetMetadata(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof rootControllerGetMetadata>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RootControllerGetMetadataQueryResult = NonNullable<
  Awaited<ReturnType<typeof rootControllerGetMetadata>>
>;
export type RootControllerGetMetadataQueryError = unknown;

export function useRootControllerGetMetadata<
  TData = Awaited<ReturnType<typeof rootControllerGetMetadata>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetMetadata>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootControllerGetMetadata>>,
          TError,
          Awaited<ReturnType<typeof rootControllerGetMetadata>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootControllerGetMetadata<
  TData = Awaited<ReturnType<typeof rootControllerGetMetadata>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetMetadata>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootControllerGetMetadata>>,
          TError,
          Awaited<ReturnType<typeof rootControllerGetMetadata>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootControllerGetMetadata<
  TData = Awaited<ReturnType<typeof rootControllerGetMetadata>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetMetadata>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get system metadata.
 */

export function useRootControllerGetMetadata<
  TData = Awaited<ReturnType<typeof rootControllerGetMetadata>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof rootControllerGetMetadata>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRootControllerGetMetadataQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Analyzes a domain and generates relevant tags using AI classification. Requires AI Assistant tool to be installed in the workspace.
 * @summary Generate tags for a domain using AI
 */
export const aiAssistantControllerGenerateTags = (
  generateTagsDto: GenerateTagsDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GenerateTagsResponseDto>(
    {
      url: `/api/ai-assistant/generate-tags`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: generateTagsDto,
      signal,
    },
    options,
  );
};

export const getAiAssistantControllerGenerateTagsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGenerateTags>>,
    TError,
    { data: GenerateTagsDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerGenerateTags>>,
  TError,
  { data: GenerateTagsDto },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerGenerateTags'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGenerateTags>>,
    { data: GenerateTagsDto }
  > = (props) => {
    const { data } = props ?? {};

    return aiAssistantControllerGenerateTags(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerGenerateTagsMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGenerateTags>>
>;
export type AiAssistantControllerGenerateTagsMutationBody = GenerateTagsDto;
export type AiAssistantControllerGenerateTagsMutationError = unknown;

/**
 * @summary Generate tags for a domain using AI
 */
export const useAiAssistantControllerGenerateTags = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerGenerateTags>>,
      TError,
      { data: GenerateTagsDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerGenerateTags>>,
  TError,
  { data: GenerateTagsDto },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerGenerateTagsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all MCP servers for the current workspace and user
 * @summary Get all MCP servers
 */
export const aiAssistantControllerGetMcpServers = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetMcpServersResponseDto>(
    { url: `/api/ai-assistant/mcp-servers`, method: 'GET', signal },
    options,
  );
};

export const getAiAssistantControllerGetMcpServersQueryKey = () => {
  return [`/api/ai-assistant/mcp-servers`] as const;
};

export const getAiAssistantControllerGetMcpServersQueryOptions = <
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAiAssistantControllerGetMcpServersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>
  > = ({ signal }) =>
    aiAssistantControllerGetMcpServers(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetMcpServersQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>
>;
export type AiAssistantControllerGetMcpServersQueryError = unknown;

export function useAiAssistantControllerGetMcpServers<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetMcpServers<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetMcpServers<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all MCP servers
 */

export function useAiAssistantControllerGetMcpServers<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAiAssistantControllerGetMcpServersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Adds one or more MCP servers to the workspace
 * @summary Add MCP servers
 */
export const aiAssistantControllerAddMcpServers = (
  addMcpServersDto: AddMcpServersDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AddMcpServersResponseDto>(
    {
      url: `/api/ai-assistant/mcp-servers`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addMcpServersDto,
      signal,
    },
    options,
  );
};

export const getAiAssistantControllerAddMcpServersMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerAddMcpServers>>,
    TError,
    { data: AddMcpServersDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerAddMcpServers>>,
  TError,
  { data: AddMcpServersDto },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerAddMcpServers'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerAddMcpServers>>,
    { data: AddMcpServersDto }
  > = (props) => {
    const { data } = props ?? {};

    return aiAssistantControllerAddMcpServers(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerAddMcpServersMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerAddMcpServers>>
>;
export type AiAssistantControllerAddMcpServersMutationBody = AddMcpServersDto;
export type AiAssistantControllerAddMcpServersMutationError = unknown;

/**
 * @summary Add MCP servers
 */
export const useAiAssistantControllerAddMcpServers = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerAddMcpServers>>,
      TError,
      { data: AddMcpServersDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerAddMcpServers>>,
  TError,
  { data: AddMcpServersDto },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerAddMcpServersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Updates one or more MCP servers
 * @summary Update MCP servers
 */
export const aiAssistantControllerUpdateMcpServers = (
  updateMcpServersDto: UpdateMcpServersDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<UpdateMcpServersResponseDto>(
    {
      url: `/api/ai-assistant/mcp-servers`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateMcpServersDto,
    },
    options,
  );
};

export const getAiAssistantControllerUpdateMcpServersMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerUpdateMcpServers>>,
    TError,
    { data: UpdateMcpServersDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateMcpServers>>,
  TError,
  { data: UpdateMcpServersDto },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerUpdateMcpServers'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerUpdateMcpServers>>,
    { data: UpdateMcpServersDto }
  > = (props) => {
    const { data } = props ?? {};

    return aiAssistantControllerUpdateMcpServers(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerUpdateMcpServersMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateMcpServers>>
>;
export type AiAssistantControllerUpdateMcpServersMutationBody =
  UpdateMcpServersDto;
export type AiAssistantControllerUpdateMcpServersMutationError = unknown;

/**
 * @summary Update MCP servers
 */
export const useAiAssistantControllerUpdateMcpServers = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerUpdateMcpServers>>,
      TError,
      { data: UpdateMcpServersDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateMcpServers>>,
  TError,
  { data: UpdateMcpServersDto },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerUpdateMcpServersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes MCP config by ID
 * @summary Delete MCP config
 */
export const aiAssistantControllerDeleteMcpServers = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DeleteMcpServersResponseDto>(
    { url: `/api/ai-assistant/mcp-servers/${id}`, method: 'DELETE' },
    options,
  );
};

export const getAiAssistantControllerDeleteMcpServersMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteMcpServers>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteMcpServers>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerDeleteMcpServers'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteMcpServers>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return aiAssistantControllerDeleteMcpServers(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerDeleteMcpServersMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteMcpServers>>
>;

export type AiAssistantControllerDeleteMcpServersMutationError = unknown;

/**
 * @summary Delete MCP config
 */
export const useAiAssistantControllerDeleteMcpServers = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerDeleteMcpServers>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteMcpServers>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerDeleteMcpServersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Gets the health status of a specific MCP server
 * @summary Get MCP server health
 */
export const aiAssistantControllerGetMcpServerHealth = (
  serverName: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetMcpServerHealthResponseDto>(
    {
      url: `/api/ai-assistant/mcp-servers/${serverName}/health`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getAiAssistantControllerGetMcpServerHealthQueryKey = (
  serverName?: string,
) => {
  return [`/api/ai-assistant/mcp-servers/${serverName}/health`] as const;
};

export const getAiAssistantControllerGetMcpServerHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
  TError = unknown,
>(
  serverName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiAssistantControllerGetMcpServerHealthQueryKey(serverName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>
  > = ({ signal }) =>
    aiAssistantControllerGetMcpServerHealth(serverName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetMcpServerHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>
>;
export type AiAssistantControllerGetMcpServerHealthQueryError = unknown;

export function useAiAssistantControllerGetMcpServerHealth<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
  TError = unknown,
>(
  serverName: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetMcpServerHealth<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
  TError = unknown,
>(
  serverName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetMcpServerHealth<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
  TError = unknown,
>(
  serverName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get MCP server health
 */

export function useAiAssistantControllerGetMcpServerHealth<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
  TError = unknown,
>(
  serverName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMcpServerHealth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAiAssistantControllerGetMcpServerHealthQueryOptions(
    serverName,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves all conversations for the current workspace and user
 * @summary Get all conversations
 */
export const aiAssistantControllerGetConversations = (
  params?: AiAssistantControllerGetConversationsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetConversationsResponseDto>(
    { url: `/api/ai-assistant/conversations`, method: 'GET', params, signal },
    options,
  );
};

export const getAiAssistantControllerGetConversationsInfiniteQueryKey = (
  params?: AiAssistantControllerGetConversationsParams,
) => {
  return [
    'infinite',
    `/api/ai-assistant/conversations`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiAssistantControllerGetConversationsQueryKey = (
  params?: AiAssistantControllerGetConversationsParams,
) => {
  return [
    `/api/ai-assistant/conversations`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiAssistantControllerGetConversationsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    AiAssistantControllerGetConversationsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetConversationsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiAssistantControllerGetConversationsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    QueryKey,
    AiAssistantControllerGetConversationsParams['page']
  > = ({ signal, pageParam }) =>
    aiAssistantControllerGetConversations(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    TError,
    TData,
    QueryKey,
    AiAssistantControllerGetConversationsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetConversationsInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>
  >;
export type AiAssistantControllerGetConversationsInfiniteQueryError = unknown;

export function useAiAssistantControllerGetConversationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    AiAssistantControllerGetConversationsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AiAssistantControllerGetConversationsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetConversationsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetConversationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    AiAssistantControllerGetConversationsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetConversationsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetConversationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    AiAssistantControllerGetConversationsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetConversationsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all conversations
 */

export function useAiAssistantControllerGetConversationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    AiAssistantControllerGetConversationsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetConversationsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAiAssistantControllerGetConversationsInfiniteQueryOptions(
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAiAssistantControllerGetConversationsQueryOptions = <
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiAssistantControllerGetConversationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>
  > = ({ signal }) =>
    aiAssistantControllerGetConversations(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetConversationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>
>;
export type AiAssistantControllerGetConversationsQueryError = unknown;

export function useAiAssistantControllerGetConversations<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
  TError = unknown,
>(
  params: undefined | AiAssistantControllerGetConversationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetConversations<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetConversations<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all conversations
 */

export function useAiAssistantControllerGetConversations<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetConversationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetConversations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAiAssistantControllerGetConversationsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Deletes all conversations for the current workspace and user
 * @summary Delete all conversations
 */
export const aiAssistantControllerDeleteConversations = (
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DeleteConversationsResponseDto>(
    { url: `/api/ai-assistant/conversations`, method: 'DELETE' },
    options,
  );
};

export const getAiAssistantControllerDeleteConversationsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteConversations>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteConversations>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['aiAssistantControllerDeleteConversations'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteConversations>>,
    void
  > = () => {
    return aiAssistantControllerDeleteConversations(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerDeleteConversationsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteConversations>>
  >;

export type AiAssistantControllerDeleteConversationsMutationError = unknown;

/**
 * @summary Delete all conversations
 */
export const useAiAssistantControllerDeleteConversations = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerDeleteConversations>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteConversations>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerDeleteConversationsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Updates the title and/or description of a conversation
 * @summary Update a conversation
 */
export const aiAssistantControllerUpdateConversation = (
  id: string,
  updateConversationDto: UpdateConversationDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<UpdateConversationResponseDto>(
    {
      url: `/api/ai-assistant/conversations/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateConversationDto,
    },
    options,
  );
};

export const getAiAssistantControllerUpdateConversationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerUpdateConversation>>,
    TError,
    { id: string; data: UpdateConversationDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateConversation>>,
  TError,
  { id: string; data: UpdateConversationDto },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerUpdateConversation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerUpdateConversation>>,
    { id: string; data: UpdateConversationDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return aiAssistantControllerUpdateConversation(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerUpdateConversationMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateConversation>>
>;
export type AiAssistantControllerUpdateConversationMutationBody =
  UpdateConversationDto;
export type AiAssistantControllerUpdateConversationMutationError = unknown;

/**
 * @summary Update a conversation
 */
export const useAiAssistantControllerUpdateConversation = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerUpdateConversation>>,
      TError,
      { id: string; data: UpdateConversationDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateConversation>>,
  TError,
  { id: string; data: UpdateConversationDto },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerUpdateConversationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a specific conversation by ID
 * @summary Delete a conversation
 */
export const aiAssistantControllerDeleteConversation = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DeleteConversationResponseDto>(
    { url: `/api/ai-assistant/conversations/${id}`, method: 'DELETE' },
    options,
  );
};

export const getAiAssistantControllerDeleteConversationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteConversation>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteConversation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerDeleteConversation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteConversation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return aiAssistantControllerDeleteConversation(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerDeleteConversationMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteConversation>>
>;

export type AiAssistantControllerDeleteConversationMutationError = unknown;

/**
 * @summary Delete a conversation
 */
export const useAiAssistantControllerDeleteConversation = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerDeleteConversation>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteConversation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerDeleteConversationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all messages in a specific conversation
 * @summary Get messages in a conversation
 */
export const aiAssistantControllerGetMessages = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetMessagesResponseDto>(
    {
      url: `/api/ai-assistant/conversations/${id}/messages`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getAiAssistantControllerGetMessagesQueryKey = (id?: string) => {
  return [`/api/ai-assistant/conversations/${id}/messages`] as const;
};

export const getAiAssistantControllerGetMessagesQueryOptions = <
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAiAssistantControllerGetMessagesQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>
  > = ({ signal }) =>
    aiAssistantControllerGetMessages(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetMessagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>
>;
export type AiAssistantControllerGetMessagesQueryError = unknown;

export function useAiAssistantControllerGetMessages<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetMessages<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetMessages<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get messages in a conversation
 */

export function useAiAssistantControllerGetMessages<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetMessages>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAiAssistantControllerGetMessagesQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Deletes a specific message by ID
 * @summary Delete a message
 */
export const aiAssistantControllerDeleteMessage = (
  conversationId: string,
  messageId: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DeleteMessageResponseDto>(
    {
      url: `/api/ai-assistant/conversations/${conversationId}/messages/${messageId}`,
      method: 'DELETE',
    },
    options,
  );
};

export const getAiAssistantControllerDeleteMessageMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteMessage>>,
    TError,
    { conversationId: string; messageId: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteMessage>>,
  TError,
  { conversationId: string; messageId: string },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerDeleteMessage'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteMessage>>,
    { conversationId: string; messageId: string }
  > = (props) => {
    const { conversationId, messageId } = props ?? {};

    return aiAssistantControllerDeleteMessage(
      conversationId,
      messageId,
      requestOptions,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerDeleteMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteMessage>>
>;

export type AiAssistantControllerDeleteMessageMutationError = unknown;

/**
 * @summary Delete a message
 */
export const useAiAssistantControllerDeleteMessage = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerDeleteMessage>>,
      TError,
      { conversationId: string; messageId: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteMessage>>,
  TError,
  { conversationId: string; messageId: string },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerDeleteMessageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all available models (internal + configured external)
 * @summary Get available models
 */
export const aiAssistantControllerGetAvailableModels = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AiAssistantControllerGetAvailableModels200>(
    { url: `/api/ai-assistant/models`, method: 'GET', signal },
    options,
  );
};

export const getAiAssistantControllerGetAvailableModelsQueryKey = () => {
  return [`/api/ai-assistant/models`] as const;
};

export const getAiAssistantControllerGetAvailableModelsQueryOptions = <
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiAssistantControllerGetAvailableModelsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>
  > = ({ signal }) =>
    aiAssistantControllerGetAvailableModels(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetAvailableModelsQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>
>;
export type AiAssistantControllerGetAvailableModelsQueryError = unknown;

export function useAiAssistantControllerGetAvailableModels<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetAvailableModels<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetAvailableModels<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get available models
 */

export function useAiAssistantControllerGetAvailableModels<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetAvailableModels>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAiAssistantControllerGetAvailableModelsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves LLM configurations/keys (masked)
 * @summary Get LLM Configs
 */
export const aiAssistantControllerGetLLMConfigs = (
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AiAssistantControllerGetLLMConfigs200>(
    { url: `/api/ai-assistant/configs`, method: 'GET', params, signal },
    options,
  );
};

export const getAiAssistantControllerGetLLMConfigsInfiniteQueryKey = (
  params?: AiAssistantControllerGetLLMConfigsParams,
) => {
  return [
    'infinite',
    `/api/ai-assistant/configs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiAssistantControllerGetLLMConfigsQueryKey = (
  params?: AiAssistantControllerGetLLMConfigsParams,
) => {
  return [`/api/ai-assistant/configs`, ...(params ? [params] : [])] as const;
};

export const getAiAssistantControllerGetLLMConfigsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    AiAssistantControllerGetLLMConfigsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetLLMConfigsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiAssistantControllerGetLLMConfigsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    QueryKey,
    AiAssistantControllerGetLLMConfigsParams['page']
  > = ({ signal, pageParam }) =>
    aiAssistantControllerGetLLMConfigs(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    TError,
    TData,
    QueryKey,
    AiAssistantControllerGetLLMConfigsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetLLMConfigsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>
>;
export type AiAssistantControllerGetLLMConfigsInfiniteQueryError = unknown;

export function useAiAssistantControllerGetLLMConfigsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    AiAssistantControllerGetLLMConfigsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AiAssistantControllerGetLLMConfigsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetLLMConfigsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetLLMConfigsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    AiAssistantControllerGetLLMConfigsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetLLMConfigsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetLLMConfigsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    AiAssistantControllerGetLLMConfigsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetLLMConfigsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get LLM Configs
 */

export function useAiAssistantControllerGetLLMConfigsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    AiAssistantControllerGetLLMConfigsParams['page']
  >,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData,
        QueryKey,
        AiAssistantControllerGetLLMConfigsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAiAssistantControllerGetLLMConfigsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAiAssistantControllerGetLLMConfigsQueryOptions = <
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiAssistantControllerGetLLMConfigsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>
  > = ({ signal }) =>
    aiAssistantControllerGetLLMConfigs(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AiAssistantControllerGetLLMConfigsQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>
>;
export type AiAssistantControllerGetLLMConfigsQueryError = unknown;

export function useAiAssistantControllerGetLLMConfigs<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
  TError = unknown,
>(
  params: undefined | AiAssistantControllerGetLLMConfigsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetLLMConfigs<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
          TError,
          Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAiAssistantControllerGetLLMConfigs<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get LLM Configs
 */

export function useAiAssistantControllerGetLLMConfigs<
  TData = Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
  TError = unknown,
>(
  params?: AiAssistantControllerGetLLMConfigsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiAssistantControllerGetLLMConfigs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAiAssistantControllerGetLLMConfigsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates or creates LLM configuration for a provider (BYOK)
 * @summary Update LLM Config
 */
export const aiAssistantControllerUpdateLLMConfig = (
  updateLLMConfigDto: UpdateLLMConfigDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<LLMConfigResponseDto>(
    {
      url: `/api/ai-assistant/configs`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: updateLLMConfigDto,
      signal,
    },
    options,
  );
};

export const getAiAssistantControllerUpdateLLMConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerUpdateLLMConfig>>,
    TError,
    { data: UpdateLLMConfigDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateLLMConfig>>,
  TError,
  { data: UpdateLLMConfigDto },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerUpdateLLMConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerUpdateLLMConfig>>,
    { data: UpdateLLMConfigDto }
  > = (props) => {
    const { data } = props ?? {};

    return aiAssistantControllerUpdateLLMConfig(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerUpdateLLMConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateLLMConfig>>
>;
export type AiAssistantControllerUpdateLLMConfigMutationBody =
  UpdateLLMConfigDto;
export type AiAssistantControllerUpdateLLMConfigMutationError = unknown;

/**
 * @summary Update LLM Config
 */
export const useAiAssistantControllerUpdateLLMConfig = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerUpdateLLMConfig>>,
      TError,
      { data: UpdateLLMConfigDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerUpdateLLMConfig>>,
  TError,
  { data: UpdateLLMConfigDto },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerUpdateLLMConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes LLM configuration by ID
 * @summary Delete LLM Config
 */
export const aiAssistantControllerDeleteLLMConfig = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/ai-assistant/configs/${id}`, method: 'DELETE' },
    options,
  );
};

export const getAiAssistantControllerDeleteLLMConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteLLMConfig>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteLLMConfig>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerDeleteLLMConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerDeleteLLMConfig>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return aiAssistantControllerDeleteLLMConfig(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerDeleteLLMConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteLLMConfig>>
>;

export type AiAssistantControllerDeleteLLMConfigMutationError = unknown;

/**
 * @summary Delete LLM Config
 */
export const useAiAssistantControllerDeleteLLMConfig = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerDeleteLLMConfig>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerDeleteLLMConfig>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerDeleteLLMConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Sets a specific LLM configuration as preferred
 * @summary Set Preferred LLM Config
 */
export const aiAssistantControllerSetPreferredLLMConfig = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<LLMConfigResponseDto>(
    { url: `/api/ai-assistant/configs/${id}/set-preferred`, method: 'PATCH' },
    options,
  );
};

export const getAiAssistantControllerSetPreferredLLMConfigMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiAssistantControllerSetPreferredLLMConfig>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiAssistantControllerSetPreferredLLMConfig>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['aiAssistantControllerSetPreferredLLMConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiAssistantControllerSetPreferredLLMConfig>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return aiAssistantControllerSetPreferredLLMConfig(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiAssistantControllerSetPreferredLLMConfigMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof aiAssistantControllerSetPreferredLLMConfig>>
  >;

export type AiAssistantControllerSetPreferredLLMConfigMutationError = unknown;

/**
 * @summary Set Preferred LLM Config
 */
export const useAiAssistantControllerSetPreferredLLMConfig = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiAssistantControllerSetPreferredLLMConfig>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiAssistantControllerSetPreferredLLMConfig>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getAiAssistantControllerSetPreferredLLMConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a list of jobs that the user is a member of.
 * @summary Get Jobs
 */
export const jobsRegistryControllerGetManyJobs = (
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyJobDto>(
    { url: `/api/jobs-registry`, method: 'GET', params, signal },
    options,
  );
};

export const getJobsRegistryControllerGetManyJobsInfiniteQueryKey = (
  params?: JobsRegistryControllerGetManyJobsParams,
) => {
  return [
    'infinite',
    `/api/jobs-registry`,
    ...(params ? [params] : []),
  ] as const;
};

export const getJobsRegistryControllerGetManyJobsQueryKey = (
  params?: JobsRegistryControllerGetManyJobsParams,
) => {
  return [`/api/jobs-registry`, ...(params ? [params] : [])] as const;
};

export const getJobsRegistryControllerGetManyJobsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    JobsRegistryControllerGetManyJobsParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getJobsRegistryControllerGetManyJobsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    QueryKey,
    JobsRegistryControllerGetManyJobsParams['page']
  > = ({ signal, pageParam }) =>
    jobsRegistryControllerGetManyJobs(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    TError,
    TData,
    QueryKey,
    JobsRegistryControllerGetManyJobsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobsRegistryControllerGetManyJobsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>
>;
export type JobsRegistryControllerGetManyJobsInfiniteQueryError = unknown;

export function useJobsRegistryControllerGetManyJobsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    JobsRegistryControllerGetManyJobsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | JobsRegistryControllerGetManyJobsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    JobsRegistryControllerGetManyJobsParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    JobsRegistryControllerGetManyJobsParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Jobs
 */

export function useJobsRegistryControllerGetManyJobsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    JobsRegistryControllerGetManyJobsParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobsRegistryControllerGetManyJobsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobsRegistryControllerGetManyJobsQueryOptions = <
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getJobsRegistryControllerGetManyJobsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>
  > = ({ signal }) =>
    jobsRegistryControllerGetManyJobs(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobsRegistryControllerGetManyJobsQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>
>;
export type JobsRegistryControllerGetManyJobsQueryError = unknown;

export function useJobsRegistryControllerGetManyJobs<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
  TError = unknown,
>(
  params: undefined | JobsRegistryControllerGetManyJobsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobs<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobs<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Jobs
 */

export function useJobsRegistryControllerGetManyJobs<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobsRegistryControllerGetManyJobsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates a new job associated with the given asset and worker name.
 */
export const jobsRegistryControllerCreateJobsForTarget = (
  createJobsDto: CreateJobsDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    {
      url: `/api/jobs-registry`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createJobsDto,
      signal,
    },
    options,
  );
};

export const getJobsRegistryControllerCreateJobsForTargetMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerCreateJobsForTarget>>,
    TError,
    { data: CreateJobsDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobsRegistryControllerCreateJobsForTarget>>,
  TError,
  { data: CreateJobsDto },
  TContext
> => {
  const mutationKey = ['jobsRegistryControllerCreateJobsForTarget'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerCreateJobsForTarget>>,
    { data: CreateJobsDto }
  > = (props) => {
    const { data } = props ?? {};

    return jobsRegistryControllerCreateJobsForTarget(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobsRegistryControllerCreateJobsForTargetMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof jobsRegistryControllerCreateJobsForTarget>>
  >;
export type JobsRegistryControllerCreateJobsForTargetMutationBody =
  CreateJobsDto;
export type JobsRegistryControllerCreateJobsForTargetMutationError = unknown;

/**
 * @summary Creates a new job associated with the given asset and worker name.
 */
export const useJobsRegistryControllerCreateJobsForTarget = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerCreateJobsForTarget>>,
      TError,
      { data: CreateJobsDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jobsRegistryControllerCreateJobsForTarget>>,
  TError,
  { data: CreateJobsDto },
  TContext
> => {
  const mutationOptions =
    getJobsRegistryControllerCreateJobsForTargetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a timeline of jobs grouped by tool name and target.
 * @summary Get Jobs Timeline
 */
export const jobsRegistryControllerGetJobsTimeline = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<JobTimelineResponseDto>(
    { url: `/api/jobs-registry/timeline`, method: 'GET', signal },
    options,
  );
};

export const getJobsRegistryControllerGetJobsTimelineQueryKey = () => {
  return [`/api/jobs-registry/timeline`] as const;
};

export const getJobsRegistryControllerGetJobsTimelineQueryOptions = <
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getJobsRegistryControllerGetJobsTimelineQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>
  > = ({ signal }) =>
    jobsRegistryControllerGetJobsTimeline(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobsRegistryControllerGetJobsTimelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>
>;
export type JobsRegistryControllerGetJobsTimelineQueryError = unknown;

export function useJobsRegistryControllerGetJobsTimeline<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetJobsTimeline<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetJobsTimeline<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Jobs Timeline
 */

export function useJobsRegistryControllerGetJobsTimeline<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobsTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getJobsRegistryControllerGetJobsTimelineQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Retrieves the next job associated with the given worker that has not yet been started.
 */
export const jobsRegistryControllerGetNextJob = (
  workerId: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetNextJobResponseDto>(
    { url: `/api/jobs-registry/${workerId}/next`, method: 'GET', signal },
    options,
  );
};

export const getJobsRegistryControllerGetNextJobQueryKey = (
  workerId?: string,
) => {
  return [`/api/jobs-registry/${workerId}/next`] as const;
};

export const getJobsRegistryControllerGetNextJobQueryOptions = <
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
  TError = unknown,
>(
  workerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getJobsRegistryControllerGetNextJobQueryKey(workerId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>
  > = ({ signal }) =>
    jobsRegistryControllerGetNextJob(workerId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!workerId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobsRegistryControllerGetNextJobQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>
>;
export type JobsRegistryControllerGetNextJobQueryError = unknown;

export function useJobsRegistryControllerGetNextJob<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
  TError = unknown,
>(
  workerId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetNextJob<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
  TError = unknown,
>(
  workerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetNextJob<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
  TError = unknown,
>(
  workerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieves the next job associated with the given worker that has not yet been started.
 */

export function useJobsRegistryControllerGetNextJob<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
  TError = unknown,
>(
  workerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetNextJob>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobsRegistryControllerGetNextJobQueryOptions(
    workerId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates the result of a job with the given worker ID.
 */
export const jobsRegistryControllerUpdateResult = (
  workerId: string,
  updateResultDto: UpdateResultDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    {
      url: `/api/jobs-registry/${workerId}/result`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: updateResultDto,
      signal,
    },
    options,
  );
};

export const getJobsRegistryControllerUpdateResultMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerUpdateResult>>,
    TError,
    { workerId: string; data: UpdateResultDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobsRegistryControllerUpdateResult>>,
  TError,
  { workerId: string; data: UpdateResultDto },
  TContext
> => {
  const mutationKey = ['jobsRegistryControllerUpdateResult'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerUpdateResult>>,
    { workerId: string; data: UpdateResultDto }
  > = (props) => {
    const { workerId, data } = props ?? {};

    return jobsRegistryControllerUpdateResult(workerId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobsRegistryControllerUpdateResultMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerUpdateResult>>
>;
export type JobsRegistryControllerUpdateResultMutationBody = UpdateResultDto;
export type JobsRegistryControllerUpdateResultMutationError = unknown;

/**
 * @summary Updates the result of a job with the given worker ID.
 */
export const useJobsRegistryControllerUpdateResult = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerUpdateResult>>,
      TError,
      { workerId: string; data: UpdateResultDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jobsRegistryControllerUpdateResult>>,
  TError,
  { workerId: string; data: UpdateResultDto },
  TContext
> => {
  const mutationOptions =
    getJobsRegistryControllerUpdateResultMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a list of job histories in the current workspace with their associated jobs, assets, and targets.
 * @summary Get Many Job Histories
 */
export const jobsRegistryControllerGetManyJobHistories = (
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyJobHistoryResponseDtoDto>(
    { url: `/api/jobs-registry/histories`, method: 'GET', params, signal },
    options,
  );
};

export const getJobsRegistryControllerGetManyJobHistoriesInfiniteQueryKey = (
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
) => {
  return [
    'infinite',
    `/api/jobs-registry/histories`,
    ...(params ? [params] : []),
  ] as const;
};

export const getJobsRegistryControllerGetManyJobHistoriesQueryKey = (
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
) => {
  return [`/api/jobs-registry/histories`, ...(params ? [params] : [])] as const;
};

export const getJobsRegistryControllerGetManyJobHistoriesInfiniteQueryOptions =
  <
    TData = InfiniteData<
      Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
      JobsRegistryControllerGetManyJobHistoriesParams['page']
    >,
    TError = unknown,
  >(
    params?: JobsRegistryControllerGetManyJobHistoriesParams,
    options?: {
      query?: Partial<
        UseInfiniteQueryOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          TError,
          TData,
          QueryKey,
          JobsRegistryControllerGetManyJobHistoriesParams['page']
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getJobsRegistryControllerGetManyJobHistoriesInfiniteQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
      QueryKey,
      JobsRegistryControllerGetManyJobHistoriesParams['page']
    > = ({ signal, pageParam }) =>
      jobsRegistryControllerGetManyJobHistories(
        { ...params, page: pageParam || params?.['page'] },
        requestOptions,
        signal,
      );

    return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
      TError,
      TData,
      QueryKey,
      JobsRegistryControllerGetManyJobHistoriesParams['page']
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type JobsRegistryControllerGetManyJobHistoriesInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>
  >;
export type JobsRegistryControllerGetManyJobHistoriesInfiniteQueryError =
  unknown;

export function useJobsRegistryControllerGetManyJobHistoriesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
    JobsRegistryControllerGetManyJobHistoriesParams['page']
  >,
  TError = unknown,
>(
  params: undefined | JobsRegistryControllerGetManyJobHistoriesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobHistoriesParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobHistoriesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
    JobsRegistryControllerGetManyJobHistoriesParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobHistoriesParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobHistoriesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
    JobsRegistryControllerGetManyJobHistoriesParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobHistoriesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Many Job Histories
 */

export function useJobsRegistryControllerGetManyJobHistoriesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
    JobsRegistryControllerGetManyJobHistoriesParams['page']
  >,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData,
        QueryKey,
        JobsRegistryControllerGetManyJobHistoriesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getJobsRegistryControllerGetManyJobHistoriesInfiniteQueryOptions(
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobsRegistryControllerGetManyJobHistoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getJobsRegistryControllerGetManyJobHistoriesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>
  > = ({ signal }) =>
    jobsRegistryControllerGetManyJobHistories(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobsRegistryControllerGetManyJobHistoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>
>;
export type JobsRegistryControllerGetManyJobHistoriesQueryError = unknown;

export function useJobsRegistryControllerGetManyJobHistories<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
  TError = unknown,
>(
  params: undefined | JobsRegistryControllerGetManyJobHistoriesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobHistories<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetManyJobHistories<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Many Job Histories
 */

export function useJobsRegistryControllerGetManyJobHistories<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
  TError = unknown,
>(
  params?: JobsRegistryControllerGetManyJobHistoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetManyJobHistories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobsRegistryControllerGetManyJobHistoriesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a job history detail with its associated workflow and jobs.
 * @summary Get Job History Detail
 */
export const jobsRegistryControllerGetJobHistoryDetail = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<JobHistoryDetailResponseDto>(
    { url: `/api/jobs-registry/histories/${id}`, method: 'GET', signal },
    options,
  );
};

export const getJobsRegistryControllerGetJobHistoryDetailQueryKey = (
  id?: string,
) => {
  return [`/api/jobs-registry/histories/${id}`] as const;
};

export const getJobsRegistryControllerGetJobHistoryDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getJobsRegistryControllerGetJobHistoryDetailQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>
  > = ({ signal }) =>
    jobsRegistryControllerGetJobHistoryDetail(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobsRegistryControllerGetJobHistoryDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>
>;
export type JobsRegistryControllerGetJobHistoryDetailQueryError = unknown;

export function useJobsRegistryControllerGetJobHistoryDetail<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetJobHistoryDetail<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
          TError,
          Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobsRegistryControllerGetJobHistoryDetail<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Job History Detail
 */

export function useJobsRegistryControllerGetJobHistoryDetail<
  TData = Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof jobsRegistryControllerGetJobHistoryDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobsRegistryControllerGetJobHistoryDetailQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reset job status to pending, clear workerId, and increment retry count
 * @summary Re-run a job
 */
export const jobsRegistryControllerReRunJob = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/jobs-registry/${id}/re-run`, method: 'POST', signal },
    options,
  );
};

export const getJobsRegistryControllerReRunJobMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerReRunJob>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobsRegistryControllerReRunJob>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['jobsRegistryControllerReRunJob'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerReRunJob>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return jobsRegistryControllerReRunJob(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobsRegistryControllerReRunJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerReRunJob>>
>;

export type JobsRegistryControllerReRunJobMutationError = unknown;

/**
 * @summary Re-run a job
 */
export const useJobsRegistryControllerReRunJob = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerReRunJob>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jobsRegistryControllerReRunJob>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getJobsRegistryControllerReRunJobMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Cancel a job by its ID in the specified workspace
 * @summary Cancel a job
 */
export const jobsRegistryControllerCancelJob = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/jobs-registry/${id}/cancel`, method: 'POST', signal },
    options,
  );
};

export const getJobsRegistryControllerCancelJobMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerCancelJob>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobsRegistryControllerCancelJob>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['jobsRegistryControllerCancelJob'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerCancelJob>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return jobsRegistryControllerCancelJob(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobsRegistryControllerCancelJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerCancelJob>>
>;

export type JobsRegistryControllerCancelJobMutationError = unknown;

/**
 * @summary Cancel a job
 */
export const useJobsRegistryControllerCancelJob = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerCancelJob>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jobsRegistryControllerCancelJob>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getJobsRegistryControllerCancelJobMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete a job by its ID in the specified workspace
 * @summary Delete a job
 */
export const jobsRegistryControllerDeleteJob = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/jobs-registry/${id}`, method: 'DELETE' },
    options,
  );
};

export const getJobsRegistryControllerDeleteJobMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobsRegistryControllerDeleteJob>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobsRegistryControllerDeleteJob>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['jobsRegistryControllerDeleteJob'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobsRegistryControllerDeleteJob>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return jobsRegistryControllerDeleteJob(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobsRegistryControllerDeleteJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobsRegistryControllerDeleteJob>>
>;

export type JobsRegistryControllerDeleteJobMutationError = unknown;

/**
 * @summary Delete a job
 */
export const useJobsRegistryControllerDeleteJob = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobsRegistryControllerDeleteJob>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof jobsRegistryControllerDeleteJob>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getJobsRegistryControllerDeleteJobMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a list of assets associated with the given target.
 * @summary Get assets in target
 */
export const assetsControllerGetAssetsInWorkspace = (
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetAssetsResponseDtoDto>(
    { url: `/api/assets`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetsControllerGetAssetsInWorkspaceInfiniteQueryKey = (
  params?: AssetsControllerGetAssetsInWorkspaceParams,
) => {
  return ['infinite', `/api/assets`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetAssetsInWorkspaceQueryKey = (
  params?: AssetsControllerGetAssetsInWorkspaceParams,
) => {
  return [`/api/assets`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetAssetsInWorkspaceInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetAssetsInWorkspaceParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetAssetsInWorkspaceInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    QueryKey,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  > = ({ signal, pageParam }) =>
    assetsControllerGetAssetsInWorkspace(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    TError,
    TData,
    QueryKey,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetAssetsInWorkspaceInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>>;
export type AssetsControllerGetAssetsInWorkspaceInfiniteQueryError = unknown;

export function useAssetsControllerGetAssetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetAssetsInWorkspaceParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetAssetsInWorkspaceParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetAssetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetAssetsInWorkspaceParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetAssetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetAssetsInWorkspaceParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets in target
 */

export function useAssetsControllerGetAssetsInWorkspaceInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    AssetsControllerGetAssetsInWorkspaceParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetAssetsInWorkspaceParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetsControllerGetAssetsInWorkspaceInfiniteQueryOptions(
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetsControllerGetAssetsInWorkspaceQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetAssetsInWorkspaceQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>
  > = ({ signal }) =>
    assetsControllerGetAssetsInWorkspace(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetAssetsInWorkspaceQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>
>;
export type AssetsControllerGetAssetsInWorkspaceQueryError = unknown;

export function useAssetsControllerGetAssetsInWorkspace<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetAssetsInWorkspaceParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetAssetsInWorkspace<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetAssetsInWorkspace<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets in target
 */

export function useAssetsControllerGetAssetsInWorkspace<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
  TError = unknown,
>(
  params?: AssetsControllerGetAssetsInWorkspaceParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetsInWorkspace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetAssetsInWorkspaceQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of ip with number of assets.
 * @summary Get IP asset
 */
export const assetsControllerGetIpAssets = (
  params?: AssetsControllerGetIpAssetsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetIpAssetsDTODto>(
    { url: `/api/assets/ip`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetsControllerGetIpAssetsInfiniteQueryKey = (
  params?: AssetsControllerGetIpAssetsParams,
) => {
  return ['infinite', `/api/assets/ip`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetIpAssetsQueryKey = (
  params?: AssetsControllerGetIpAssetsParams,
) => {
  return [`/api/assets/ip`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetIpAssetsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    AssetsControllerGetIpAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetIpAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetIpAssetsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    QueryKey,
    AssetsControllerGetIpAssetsParams['page']
  > = ({ signal, pageParam }) =>
    assetsControllerGetIpAssets(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    TError,
    TData,
    QueryKey,
    AssetsControllerGetIpAssetsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetIpAssetsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetIpAssets>>
>;
export type AssetsControllerGetIpAssetsInfiniteQueryError = unknown;

export function useAssetsControllerGetIpAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    AssetsControllerGetIpAssetsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetIpAssetsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetIpAssetsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetIpAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    AssetsControllerGetIpAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetIpAssetsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetIpAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    AssetsControllerGetIpAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetIpAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get IP asset
 */

export function useAssetsControllerGetIpAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    AssetsControllerGetIpAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetIpAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetIpAssetsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetsControllerGetIpAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetIpAssetsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>
  > = ({ signal }) =>
    assetsControllerGetIpAssets(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetIpAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetIpAssets>>
>;
export type AssetsControllerGetIpAssetsQueryError = unknown;

export function useAssetsControllerGetIpAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetIpAssetsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetIpAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetIpAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetIpAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get IP asset
 */

export function useAssetsControllerGetIpAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetIpAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetIpAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetIpAssetsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of host with number of assets.
 * @summary Get host asset
 */
export const assetsControllerGetHostAssets = (
  params?: AssetsControllerGetHostAssetsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetHostAssetsDTODto>(
    { url: `/api/assets/host`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetsControllerGetHostAssetsInfiniteQueryKey = (
  params?: AssetsControllerGetHostAssetsParams,
) => {
  return ['infinite', `/api/assets/host`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetHostAssetsQueryKey = (
  params?: AssetsControllerGetHostAssetsParams,
) => {
  return [`/api/assets/host`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetHostAssetsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    AssetsControllerGetHostAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetHostAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetHostAssetsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    QueryKey,
    AssetsControllerGetHostAssetsParams['page']
  > = ({ signal, pageParam }) =>
    assetsControllerGetHostAssets(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    TError,
    TData,
    QueryKey,
    AssetsControllerGetHostAssetsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetHostAssetsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetHostAssets>>
>;
export type AssetsControllerGetHostAssetsInfiniteQueryError = unknown;

export function useAssetsControllerGetHostAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    AssetsControllerGetHostAssetsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetHostAssetsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetHostAssetsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetHostAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    AssetsControllerGetHostAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetHostAssetsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetHostAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    AssetsControllerGetHostAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetHostAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get host asset
 */

export function useAssetsControllerGetHostAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    AssetsControllerGetHostAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetHostAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetHostAssetsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetsControllerGetHostAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetHostAssetsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>
  > = ({ signal }) =>
    assetsControllerGetHostAssets(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetHostAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetHostAssets>>
>;
export type AssetsControllerGetHostAssetsQueryError = unknown;

export function useAssetsControllerGetHostAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetHostAssetsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetHostAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetHostAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetHostAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get host asset
 */

export function useAssetsControllerGetHostAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetHostAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetHostAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetHostAssetsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of port with number of assets.
 * @summary Get ports and number of assets
 */
export const assetsControllerGetPortAssets = (
  params?: AssetsControllerGetPortAssetsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetPortAssetsDTODto>(
    { url: `/api/assets/port`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetsControllerGetPortAssetsInfiniteQueryKey = (
  params?: AssetsControllerGetPortAssetsParams,
) => {
  return ['infinite', `/api/assets/port`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetPortAssetsQueryKey = (
  params?: AssetsControllerGetPortAssetsParams,
) => {
  return [`/api/assets/port`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetPortAssetsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    AssetsControllerGetPortAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetPortAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetPortAssetsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    QueryKey,
    AssetsControllerGetPortAssetsParams['page']
  > = ({ signal, pageParam }) =>
    assetsControllerGetPortAssets(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    TError,
    TData,
    QueryKey,
    AssetsControllerGetPortAssetsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetPortAssetsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetPortAssets>>
>;
export type AssetsControllerGetPortAssetsInfiniteQueryError = unknown;

export function useAssetsControllerGetPortAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    AssetsControllerGetPortAssetsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetPortAssetsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetPortAssetsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetPortAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    AssetsControllerGetPortAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetPortAssetsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetPortAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    AssetsControllerGetPortAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetPortAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get ports and number of assets
 */

export function useAssetsControllerGetPortAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    AssetsControllerGetPortAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetPortAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetPortAssetsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetsControllerGetPortAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetPortAssetsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>
  > = ({ signal }) =>
    assetsControllerGetPortAssets(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetPortAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetPortAssets>>
>;
export type AssetsControllerGetPortAssetsQueryError = unknown;

export function useAssetsControllerGetPortAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetPortAssetsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetPortAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetPortAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetPortAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get ports and number of assets
 */

export function useAssetsControllerGetPortAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetPortAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetPortAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetPortAssetsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of technologies with number of assets.
 * @summary Get technologies along with number of assets
 */
export const assetsControllerGetTechnologyAssets = (
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetTechnologyAssetsDTODto>(
    { url: `/api/assets/tech`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetsControllerGetTechnologyAssetsInfiniteQueryKey = (
  params?: AssetsControllerGetTechnologyAssetsParams,
) => {
  return ['infinite', `/api/assets/tech`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetTechnologyAssetsQueryKey = (
  params?: AssetsControllerGetTechnologyAssetsParams,
) => {
  return [`/api/assets/tech`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetTechnologyAssetsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    AssetsControllerGetTechnologyAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetTechnologyAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetTechnologyAssetsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    QueryKey,
    AssetsControllerGetTechnologyAssetsParams['page']
  > = ({ signal, pageParam }) =>
    assetsControllerGetTechnologyAssets(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    TError,
    TData,
    QueryKey,
    AssetsControllerGetTechnologyAssetsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetTechnologyAssetsInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>>;
export type AssetsControllerGetTechnologyAssetsInfiniteQueryError = unknown;

export function useAssetsControllerGetTechnologyAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    AssetsControllerGetTechnologyAssetsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetTechnologyAssetsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetTechnologyAssetsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetTechnologyAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    AssetsControllerGetTechnologyAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetTechnologyAssetsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetTechnologyAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    AssetsControllerGetTechnologyAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetTechnologyAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get technologies along with number of assets
 */

export function useAssetsControllerGetTechnologyAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    AssetsControllerGetTechnologyAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetTechnologyAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetsControllerGetTechnologyAssetsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetsControllerGetTechnologyAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetTechnologyAssetsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>
  > = ({ signal }) =>
    assetsControllerGetTechnologyAssets(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetTechnologyAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>
>;
export type AssetsControllerGetTechnologyAssetsQueryError = unknown;

export function useAssetsControllerGetTechnologyAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetTechnologyAssetsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetTechnologyAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetTechnologyAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get technologies along with number of assets
 */

export function useAssetsControllerGetTechnologyAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetTechnologyAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTechnologyAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetTechnologyAssetsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of technologies with number of assets.
 * @summary Get technologies along with number of assets
 */
export const assetsControllerGetStatusCodeAssets = (
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetStatusCodeAssetsDTODto>(
    { url: `/api/assets/status-code`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetsControllerGetStatusCodeAssetsInfiniteQueryKey = (
  params?: AssetsControllerGetStatusCodeAssetsParams,
) => {
  return [
    'infinite',
    `/api/assets/status-code`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetsControllerGetStatusCodeAssetsQueryKey = (
  params?: AssetsControllerGetStatusCodeAssetsParams,
) => {
  return [`/api/assets/status-code`, ...(params ? [params] : [])] as const;
};

export const getAssetsControllerGetStatusCodeAssetsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    AssetsControllerGetStatusCodeAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetStatusCodeAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetStatusCodeAssetsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    QueryKey,
    AssetsControllerGetStatusCodeAssetsParams['page']
  > = ({ signal, pageParam }) =>
    assetsControllerGetStatusCodeAssets(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    TError,
    TData,
    QueryKey,
    AssetsControllerGetStatusCodeAssetsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetStatusCodeAssetsInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>>;
export type AssetsControllerGetStatusCodeAssetsInfiniteQueryError = unknown;

export function useAssetsControllerGetStatusCodeAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    AssetsControllerGetStatusCodeAssetsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetStatusCodeAssetsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetStatusCodeAssetsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetStatusCodeAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    AssetsControllerGetStatusCodeAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetStatusCodeAssetsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetStatusCodeAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    AssetsControllerGetStatusCodeAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetStatusCodeAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get technologies along with number of assets
 */

export function useAssetsControllerGetStatusCodeAssetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    AssetsControllerGetStatusCodeAssetsParams['page']
  >,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData,
        QueryKey,
        AssetsControllerGetStatusCodeAssetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetsControllerGetStatusCodeAssetsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetsControllerGetStatusCodeAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetStatusCodeAssetsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>
  > = ({ signal }) =>
    assetsControllerGetStatusCodeAssets(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetStatusCodeAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>
>;
export type AssetsControllerGetStatusCodeAssetsQueryError = unknown;

export function useAssetsControllerGetStatusCodeAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
  TError = unknown,
>(
  params: undefined | AssetsControllerGetStatusCodeAssetsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetStatusCodeAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetStatusCodeAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get technologies along with number of assets
 */

export function useAssetsControllerGetStatusCodeAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
  TError = unknown,
>(
  params?: AssetsControllerGetStatusCodeAssetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetStatusCodeAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetStatusCodeAssetsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of TLS certificates expiring soon.
 * @summary Get TLS certificates
 */
export const assetsControllerGetTlsAssets = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetTlsResponseDtoDto>(
    { url: `/api/assets/tls`, method: 'GET', signal },
    options,
  );
};

export const getAssetsControllerGetTlsAssetsQueryKey = () => {
  return [`/api/assets/tls`] as const;
};

export const getAssetsControllerGetTlsAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetTlsAssetsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>
  > = ({ signal }) => assetsControllerGetTlsAssets(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetTlsAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>
>;
export type AssetsControllerGetTlsAssetsQueryError = unknown;

export function useAssetsControllerGetTlsAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetTlsAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetTlsAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get TLS certificates
 */

export function useAssetsControllerGetTlsAssets<
  TData = Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetTlsAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetTlsAssetsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a single asset by its ID.
 * @summary Get asset by ID
 */
export const assetsControllerGetAssetById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetAssetsResponseDto>(
    { url: `/api/assets/${id}`, method: 'GET', signal },
    options,
  );
};

export const getAssetsControllerGetAssetByIdQueryKey = (id?: string) => {
  return [`/api/assets/${id}`] as const;
};

export const getAssetsControllerGetAssetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetAssetByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetAssetById>>
  > = ({ signal }) => assetsControllerGetAssetById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerGetAssetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetAssetById>>
>;
export type AssetsControllerGetAssetByIdQueryError = unknown;

export function useAssetsControllerGetAssetById<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetAssetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetAssetById<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerGetAssetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerGetAssetById<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get asset by ID
 */

export function useAssetsControllerGetAssetById<
  TData = Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerGetAssetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetsControllerGetAssetByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an asset by its ID. Only tags can be updated.
 * @summary Update asset by ID
 */
export const assetsControllerUpdateAssetById = (
  id: string,
  updateAssetDto: UpdateAssetDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<GetAssetsResponseDto>(
    {
      url: `/api/assets/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateAssetDto,
    },
    options,
  );
};

export const getAssetsControllerUpdateAssetByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsControllerUpdateAssetById>>,
    TError,
    { id: string; data: UpdateAssetDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsControllerUpdateAssetById>>,
  TError,
  { id: string; data: UpdateAssetDto },
  TContext
> => {
  const mutationKey = ['assetsControllerUpdateAssetById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsControllerUpdateAssetById>>,
    { id: string; data: UpdateAssetDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return assetsControllerUpdateAssetById(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetsControllerUpdateAssetByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerUpdateAssetById>>
>;
export type AssetsControllerUpdateAssetByIdMutationBody = UpdateAssetDto;
export type AssetsControllerUpdateAssetByIdMutationError = unknown;

/**
 * @summary Update asset by ID
 */
export const useAssetsControllerUpdateAssetById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetsControllerUpdateAssetById>>,
      TError,
      { id: string; data: UpdateAssetDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetsControllerUpdateAssetById>>,
  TError,
  { id: string; data: UpdateAssetDto },
  TContext
> => {
  const mutationOptions =
    getAssetsControllerUpdateAssetByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Toggle the enabled/disabled status of an asset.
 * @summary Switch asset enabled/disabled
 */
export const assetsControllerSwitchAsset = (
  switchAssetDto: SwitchAssetDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetAssetsResponseDto>(
    {
      url: `/api/assets/switch`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: switchAssetDto,
      signal,
    },
    options,
  );
};

export const getAssetsControllerSwitchAssetMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetsControllerSwitchAsset>>,
    TError,
    { data: SwitchAssetDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetsControllerSwitchAsset>>,
  TError,
  { data: SwitchAssetDto },
  TContext
> => {
  const mutationKey = ['assetsControllerSwitchAsset'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetsControllerSwitchAsset>>,
    { data: SwitchAssetDto }
  > = (props) => {
    const { data } = props ?? {};

    return assetsControllerSwitchAsset(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetsControllerSwitchAssetMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerSwitchAsset>>
>;
export type AssetsControllerSwitchAssetMutationBody = SwitchAssetDto;
export type AssetsControllerSwitchAssetMutationError = unknown;

/**
 * @summary Switch asset enabled/disabled
 */
export const useAssetsControllerSwitchAsset = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetsControllerSwitchAsset>>,
      TError,
      { data: SwitchAssetDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetsControllerSwitchAsset>>,
  TError,
  { data: SwitchAssetDto },
  TContext
> => {
  const mutationOptions =
    getAssetsControllerSwitchAssetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Exports all services in a workspace to a CSV file containing value, ports, technologies, and TLS information for reporting and analysis purposes.
 * @summary Export services to CSV
 */
export const assetsControllerExportServicesToCSV = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/assets/services/export`, method: 'GET', signal },
    options,
  );
};

export const getAssetsControllerExportServicesToCSVQueryKey = () => {
  return [`/api/assets/services/export`] as const;
};

export const getAssetsControllerExportServicesToCSVQueryOptions = <
  TData = Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerExportServicesToCSVQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>
  > = ({ signal }) =>
    assetsControllerExportServicesToCSV(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetsControllerExportServicesToCSVQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>
>;
export type AssetsControllerExportServicesToCSVQueryError = unknown;

export function useAssetsControllerExportServicesToCSV<
  TData = Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerExportServicesToCSV<
  TData = Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
          TError,
          Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetsControllerExportServicesToCSV<
  TData = Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Export services to CSV
 */

export function useAssetsControllerExportServicesToCSV<
  TData = Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetsControllerExportServicesToCSV>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetsControllerExportServicesToCSVQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Confirms the operational status of a security assessment worker node in the cluster.
 * @summary Worker alive
 */
export const workersControllerAlive = (
  workerAliveDto: WorkerAliveDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/workers/alive`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: workerAliveDto,
      signal,
    },
    options,
  );
};

export const getWorkersControllerAliveMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workersControllerAlive>>,
    TError,
    { data: WorkerAliveDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workersControllerAlive>>,
  TError,
  { data: WorkerAliveDto },
  TContext
> => {
  const mutationKey = ['workersControllerAlive'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workersControllerAlive>>,
    { data: WorkerAliveDto }
  > = (props) => {
    const { data } = props ?? {};

    return workersControllerAlive(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkersControllerAliveMutationResult = NonNullable<
  Awaited<ReturnType<typeof workersControllerAlive>>
>;
export type WorkersControllerAliveMutationBody = WorkerAliveDto;
export type WorkersControllerAliveMutationError = unknown;

/**
 * @summary Worker alive
 */
export const useWorkersControllerAlive = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workersControllerAlive>>,
      TError,
      { data: WorkerAliveDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workersControllerAlive>>,
  TError,
  { data: WorkerAliveDto },
  TContext
> => {
  const mutationOptions = getWorkersControllerAliveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Registers a new security assessment worker node to the distributed processing cluster.
 * @summary Worker join
 */
export const workersControllerJoin = (
  workerJoinDto: WorkerJoinDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<WorkerInstance>(
    {
      url: `/api/workers/join`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: workerJoinDto,
      signal,
    },
    options,
  );
};

export const getWorkersControllerJoinMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof workersControllerJoin>>,
    TError,
    { data: WorkerJoinDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof workersControllerJoin>>,
  TError,
  { data: WorkerJoinDto },
  TContext
> => {
  const mutationKey = ['workersControllerJoin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof workersControllerJoin>>,
    { data: WorkerJoinDto }
  > = (props) => {
    const { data } = props ?? {};

    return workersControllerJoin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WorkersControllerJoinMutationResult = NonNullable<
  Awaited<ReturnType<typeof workersControllerJoin>>
>;
export type WorkersControllerJoinMutationBody = WorkerJoinDto;
export type WorkersControllerJoinMutationError = unknown;

/**
 * @summary Worker join
 */
export const useWorkersControllerJoin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof workersControllerJoin>>,
      TError,
      { data: WorkerJoinDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof workersControllerJoin>>,
  TError,
  { data: WorkerJoinDto },
  TContext
> => {
  const mutationOptions = getWorkersControllerJoinMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Fetches a paginated list of all active security assessment workers in the cluster.
 * @summary Get all workers with pagination and sorting.
 */
export const workersControllerGetWorkers = (
  params?: WorkersControllerGetWorkersParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyWorkerInstanceDto>(
    { url: `/api/workers`, method: 'GET', params, signal },
    options,
  );
};

export const getWorkersControllerGetWorkersInfiniteQueryKey = (
  params?: WorkersControllerGetWorkersParams,
) => {
  return ['infinite', `/api/workers`, ...(params ? [params] : [])] as const;
};

export const getWorkersControllerGetWorkersQueryKey = (
  params?: WorkersControllerGetWorkersParams,
) => {
  return [`/api/workers`, ...(params ? [params] : [])] as const;
};

export const getWorkersControllerGetWorkersInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    WorkersControllerGetWorkersParams['page']
  >,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData,
        QueryKey,
        WorkersControllerGetWorkersParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWorkersControllerGetWorkersInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    QueryKey,
    WorkersControllerGetWorkersParams['page']
  > = ({ signal, pageParam }) =>
    workersControllerGetWorkers(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    TError,
    TData,
    QueryKey,
    WorkersControllerGetWorkersParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkersControllerGetWorkersInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof workersControllerGetWorkers>>
>;
export type WorkersControllerGetWorkersInfiniteQueryError = unknown;

export function useWorkersControllerGetWorkersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    WorkersControllerGetWorkersParams['page']
  >,
  TError = unknown,
>(
  params: undefined | WorkersControllerGetWorkersParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData,
        QueryKey,
        WorkersControllerGetWorkersParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workersControllerGetWorkers>>,
          TError,
          Awaited<ReturnType<typeof workersControllerGetWorkers>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkersControllerGetWorkersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    WorkersControllerGetWorkersParams['page']
  >,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData,
        QueryKey,
        WorkersControllerGetWorkersParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workersControllerGetWorkers>>,
          TError,
          Awaited<ReturnType<typeof workersControllerGetWorkers>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkersControllerGetWorkersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    WorkersControllerGetWorkersParams['page']
  >,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData,
        QueryKey,
        WorkersControllerGetWorkersParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all workers with pagination and sorting.
 */

export function useWorkersControllerGetWorkersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    WorkersControllerGetWorkersParams['page']
  >,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData,
        QueryKey,
        WorkersControllerGetWorkersParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkersControllerGetWorkersInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getWorkersControllerGetWorkersQueryOptions = <
  TData = Awaited<ReturnType<typeof workersControllerGetWorkers>>,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getWorkersControllerGetWorkersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>
  > = ({ signal }) =>
    workersControllerGetWorkers(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof workersControllerGetWorkers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WorkersControllerGetWorkersQueryResult = NonNullable<
  Awaited<ReturnType<typeof workersControllerGetWorkers>>
>;
export type WorkersControllerGetWorkersQueryError = unknown;

export function useWorkersControllerGetWorkers<
  TData = Awaited<ReturnType<typeof workersControllerGetWorkers>>,
  TError = unknown,
>(
  params: undefined | WorkersControllerGetWorkersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof workersControllerGetWorkers>>,
          TError,
          Awaited<ReturnType<typeof workersControllerGetWorkers>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkersControllerGetWorkers<
  TData = Awaited<ReturnType<typeof workersControllerGetWorkers>>,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof workersControllerGetWorkers>>,
          TError,
          Awaited<ReturnType<typeof workersControllerGetWorkers>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkersControllerGetWorkers<
  TData = Awaited<ReturnType<typeof workersControllerGetWorkers>>,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all workers with pagination and sorting.
 */

export function useWorkersControllerGetWorkers<
  TData = Awaited<ReturnType<typeof workersControllerGetWorkers>>,
  TError = unknown,
>(
  params?: WorkersControllerGetWorkersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof workersControllerGetWorkers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWorkersControllerGetWorkersQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Search assets and targets
 * @summary Search assets and targets
 */
export const searchControllerSearchAssetsTargets = (
  params: SearchControllerSearchAssetsTargetsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<SearchResponseDto>(
    { url: `/api/search`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchControllerSearchAssetsTargetsInfiniteQueryKey = (
  params?: SearchControllerSearchAssetsTargetsParams,
) => {
  return ['infinite', `/api/search`, ...(params ? [params] : [])] as const;
};

export const getSearchControllerSearchAssetsTargetsQueryKey = (
  params?: SearchControllerSearchAssetsTargetsParams,
) => {
  return [`/api/search`, ...(params ? [params] : [])] as const;
};

export const getSearchControllerSearchAssetsTargetsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    SearchControllerSearchAssetsTargetsParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData,
        QueryKey,
        SearchControllerSearchAssetsTargetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSearchControllerSearchAssetsTargetsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    QueryKey,
    SearchControllerSearchAssetsTargetsParams['page']
  > = ({ signal, pageParam }) =>
    searchControllerSearchAssetsTargets(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    TError,
    TData,
    QueryKey,
    SearchControllerSearchAssetsTargetsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchControllerSearchAssetsTargetsInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>>;
export type SearchControllerSearchAssetsTargetsInfiniteQueryError = unknown;

export function useSearchControllerSearchAssetsTargetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    SearchControllerSearchAssetsTargetsParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData,
        QueryKey,
        SearchControllerSearchAssetsTargetsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
          TError,
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerSearchAssetsTargetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    SearchControllerSearchAssetsTargetsParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData,
        QueryKey,
        SearchControllerSearchAssetsTargetsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
          TError,
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerSearchAssetsTargetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    SearchControllerSearchAssetsTargetsParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData,
        QueryKey,
        SearchControllerSearchAssetsTargetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search assets and targets
 */

export function useSearchControllerSearchAssetsTargetsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    SearchControllerSearchAssetsTargetsParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData,
        QueryKey,
        SearchControllerSearchAssetsTargetsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getSearchControllerSearchAssetsTargetsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchControllerSearchAssetsTargetsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSearchControllerSearchAssetsTargetsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>
  > = ({ signal }) =>
    searchControllerSearchAssetsTargets(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchControllerSearchAssetsTargetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>
>;
export type SearchControllerSearchAssetsTargetsQueryError = unknown;

export function useSearchControllerSearchAssetsTargets<
  TData = Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
          TError,
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerSearchAssetsTargets<
  TData = Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
          TError,
          Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerSearchAssetsTargets<
  TData = Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search assets and targets
 */

export function useSearchControllerSearchAssetsTargets<
  TData = Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
  TError = unknown,
>(
  params: SearchControllerSearchAssetsTargetsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerSearchAssetsTargets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchControllerSearchAssetsTargetsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get search history
 * @summary Get search history
 */
export const searchControllerGetSearchHistory = (
  params: SearchControllerGetSearchHistoryParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyGetSearchHistoryResponseDtoDto>(
    { url: `/api/search/histories`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchControllerGetSearchHistoryInfiniteQueryKey = (
  params?: SearchControllerGetSearchHistoryParams,
) => {
  return [
    'infinite',
    `/api/search/histories`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSearchControllerGetSearchHistoryQueryKey = (
  params?: SearchControllerGetSearchHistoryParams,
) => {
  return [`/api/search/histories`, ...(params ? [params] : [])] as const;
};

export const getSearchControllerGetSearchHistoryInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    SearchControllerGetSearchHistoryParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData,
        QueryKey,
        SearchControllerGetSearchHistoryParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSearchControllerGetSearchHistoryInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    QueryKey,
    SearchControllerGetSearchHistoryParams['page']
  > = ({ signal, pageParam }) =>
    searchControllerGetSearchHistory(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    TError,
    TData,
    QueryKey,
    SearchControllerGetSearchHistoryParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchControllerGetSearchHistoryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchControllerGetSearchHistory>>
>;
export type SearchControllerGetSearchHistoryInfiniteQueryError = unknown;

export function useSearchControllerGetSearchHistoryInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    SearchControllerGetSearchHistoryParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData,
        QueryKey,
        SearchControllerGetSearchHistoryParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
          TError,
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerGetSearchHistoryInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    SearchControllerGetSearchHistoryParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData,
        QueryKey,
        SearchControllerGetSearchHistoryParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
          TError,
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerGetSearchHistoryInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    SearchControllerGetSearchHistoryParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData,
        QueryKey,
        SearchControllerGetSearchHistoryParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get search history
 */

export function useSearchControllerGetSearchHistoryInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    SearchControllerGetSearchHistoryParams['page']
  >,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData,
        QueryKey,
        SearchControllerGetSearchHistoryParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchControllerGetSearchHistoryInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchControllerGetSearchHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSearchControllerGetSearchHistoryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>
  > = ({ signal }) =>
    searchControllerGetSearchHistory(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchControllerGetSearchHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchControllerGetSearchHistory>>
>;
export type SearchControllerGetSearchHistoryQueryError = unknown;

export function useSearchControllerGetSearchHistory<
  TData = Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
          TError,
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerGetSearchHistory<
  TData = Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
          TError,
          Awaited<ReturnType<typeof searchControllerGetSearchHistory>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchControllerGetSearchHistory<
  TData = Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get search history
 */

export function useSearchControllerGetSearchHistory<
  TData = Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
  TError = unknown,
>(
  params: SearchControllerGetSearchHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchControllerGetSearchHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchControllerGetSearchHistoryQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete all search history entries for the user
 * @summary Delete all search history
 */
export const searchControllerDeleteAllSearchHistories = (
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DeleteResponseDto>(
    { url: `/api/search/histories`, method: 'DELETE' },
    options,
  );
};

export const getSearchControllerDeleteAllSearchHistoriesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchControllerDeleteAllSearchHistories>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchControllerDeleteAllSearchHistories>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['searchControllerDeleteAllSearchHistories'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchControllerDeleteAllSearchHistories>>,
    void
  > = () => {
    return searchControllerDeleteAllSearchHistories(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchControllerDeleteAllSearchHistoriesMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof searchControllerDeleteAllSearchHistories>>
  >;

export type SearchControllerDeleteAllSearchHistoriesMutationError = unknown;

/**
 * @summary Delete all search history
 */
export const useSearchControllerDeleteAllSearchHistories = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchControllerDeleteAllSearchHistories>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof searchControllerDeleteAllSearchHistories>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getSearchControllerDeleteAllSearchHistoriesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete a specific search history entry by its ID
 * @summary Delete search history by ID
 */
export const searchControllerDeleteSearchHistory = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DeleteResponseDto>(
    { url: `/api/search/histories/${id}`, method: 'DELETE' },
    options,
  );
};

export const getSearchControllerDeleteSearchHistoryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchControllerDeleteSearchHistory>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchControllerDeleteSearchHistory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['searchControllerDeleteSearchHistory'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchControllerDeleteSearchHistory>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return searchControllerDeleteSearchHistory(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchControllerDeleteSearchHistoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchControllerDeleteSearchHistory>>
>;

export type SearchControllerDeleteSearchHistoryMutationError = unknown;

/**
 * @summary Delete search history by ID
 */
export const useSearchControllerDeleteSearchHistory = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchControllerDeleteSearchHistory>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof searchControllerDeleteSearchHistory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getSearchControllerDeleteSearchHistoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves statistics for a workspace including total targets, assets, vulnerabilities, and unique technologies.
 * @summary Get workspace statistics
 */
export const statisticControllerGetStatistics = (
  params: StatisticControllerGetStatisticsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<StatisticResponseDto>(
    { url: `/api/statistic`, method: 'GET', params, signal },
    options,
  );
};

export const getStatisticControllerGetStatisticsQueryKey = (
  params?: StatisticControllerGetStatisticsParams,
) => {
  return [`/api/statistic`, ...(params ? [params] : [])] as const;
};

export const getStatisticControllerGetStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
  TError = unknown,
>(
  params: StatisticControllerGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getStatisticControllerGetStatisticsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statisticControllerGetStatistics>>
  > = ({ signal }) =>
    statisticControllerGetStatistics(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatisticControllerGetStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof statisticControllerGetStatistics>>
>;
export type StatisticControllerGetStatisticsQueryError = unknown;

export function useStatisticControllerGetStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
  TError = unknown,
>(
  params: StatisticControllerGetStatisticsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
  TError = unknown,
>(
  params: StatisticControllerGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
  TError = unknown,
>(
  params: StatisticControllerGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workspace statistics
 */

export function useStatisticControllerGetStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
  TError = unknown,
>(
  params: StatisticControllerGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStatisticControllerGetStatisticsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves statistics for a workspace over the last 3 months, showing trends and changes over time.
 * @summary Get timeline statistics for a workspace
 */
export const statisticControllerGetTimelineStatistics = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<TimelineResponseDto>(
    { url: `/api/statistic/timeline`, method: 'GET', signal },
    options,
  );
};

export const getStatisticControllerGetTimelineStatisticsQueryKey = () => {
  return [`/api/statistic/timeline`] as const;
};

export const getStatisticControllerGetTimelineStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getStatisticControllerGetTimelineStatisticsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>
  > = ({ signal }) =>
    statisticControllerGetTimelineStatistics(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatisticControllerGetTimelineStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>
>;
export type StatisticControllerGetTimelineStatisticsQueryError = unknown;

export function useStatisticControllerGetTimelineStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetTimelineStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetTimelineStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get timeline statistics for a workspace
 */

export function useStatisticControllerGetTimelineStatistics<
  TData = Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTimelineStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getStatisticControllerGetTimelineStatisticsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves issues timeline statistics for a workspace, showing the number of vulnerabilities over time.
 * @summary Get issues timeline statistics for a workspace
 */
export const statisticControllerGetIssuesTimeline = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<IssuesTimelineResponseDto>(
    { url: `/api/statistic/issues-timeline`, method: 'GET', signal },
    options,
  );
};

export const getStatisticControllerGetIssuesTimelineQueryKey = () => {
  return [`/api/statistic/issues-timeline`] as const;
};

export const getStatisticControllerGetIssuesTimelineQueryOptions = <
  TData = Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStatisticControllerGetIssuesTimelineQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>
  > = ({ signal }) =>
    statisticControllerGetIssuesTimeline(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatisticControllerGetIssuesTimelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>
>;
export type StatisticControllerGetIssuesTimelineQueryError = unknown;

export function useStatisticControllerGetIssuesTimeline<
  TData = Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetIssuesTimeline<
  TData = Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetIssuesTimeline<
  TData = Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get issues timeline statistics for a workspace
 */

export function useStatisticControllerGetIssuesTimeline<
  TData = Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetIssuesTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getStatisticControllerGetIssuesTimelineQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the top 10 tags with the most assets in a workspace.
 * @summary Get top 10 tags with the most assets in a workspace
 */
export const statisticControllerGetTopTagsAssets = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<TopTagAsset[]>(
    { url: `/api/statistic/top-tags-assets`, method: 'GET', signal },
    options,
  );
};

export const getStatisticControllerGetTopTagsAssetsQueryKey = () => {
  return [`/api/statistic/top-tags-assets`] as const;
};

export const getStatisticControllerGetTopTagsAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStatisticControllerGetTopTagsAssetsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>
  > = ({ signal }) =>
    statisticControllerGetTopTagsAssets(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatisticControllerGetTopTagsAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>
>;
export type StatisticControllerGetTopTagsAssetsQueryError = unknown;

export function useStatisticControllerGetTopTagsAssets<
  TData = Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetTopTagsAssets<
  TData = Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetTopTagsAssets<
  TData = Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get top 10 tags with the most assets in a workspace
 */

export function useStatisticControllerGetTopTagsAssets<
  TData = Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetTopTagsAssets>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getStatisticControllerGetTopTagsAssetsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the location of assets in a workspace.
 * @summary Get assets location
 */
export const statisticControllerGetAssetLocations = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GeoIp[]>(
    { url: `/api/statistic/asset-locations`, method: 'GET', signal },
    options,
  );
};

export const getStatisticControllerGetAssetLocationsQueryKey = () => {
  return [`/api/statistic/asset-locations`] as const;
};

export const getStatisticControllerGetAssetLocationsQueryOptions = <
  TData = Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStatisticControllerGetAssetLocationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>
  > = ({ signal }) =>
    statisticControllerGetAssetLocations(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatisticControllerGetAssetLocationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>
>;
export type StatisticControllerGetAssetLocationsQueryError = unknown;

export function useStatisticControllerGetAssetLocations<
  TData = Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetAssetLocations<
  TData = Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
          TError,
          Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetAssetLocations<
  TData = Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets location
 */

export function useStatisticControllerGetAssetLocations<
  TData = Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof statisticControllerGetAssetLocations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getStatisticControllerGetAssetLocationsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the top 10 assets with the most vulnerabilities in a workspace.
 * @summary Get top 10 assets with the most vulnerabilities in a workspace
 */
export const statisticControllerGetTopAssetsWithMostVulnerabilities = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<TopAssetVulnerabilities[]>(
    { url: `/api/statistic/top-assets-vulnerabilities`, method: 'GET', signal },
    options,
  );
};

export const getStatisticControllerGetTopAssetsWithMostVulnerabilitiesQueryKey =
  () => {
    return [`/api/statistic/top-assets-vulnerabilities`] as const;
  };

export const getStatisticControllerGetTopAssetsWithMostVulnerabilitiesQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof statisticControllerGetTopAssetsWithMostVulnerabilities>
    >,
    TError = unknown,
  >(options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof statisticControllerGetTopAssetsWithMostVulnerabilities
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  }) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getStatisticControllerGetTopAssetsWithMostVulnerabilitiesQueryKey();

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof statisticControllerGetTopAssetsWithMostVulnerabilities
        >
      >
    > = ({ signal }) =>
      statisticControllerGetTopAssetsWithMostVulnerabilities(
        requestOptions,
        signal,
      );

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof statisticControllerGetTopAssetsWithMostVulnerabilities
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type StatisticControllerGetTopAssetsWithMostVulnerabilitiesQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof statisticControllerGetTopAssetsWithMostVulnerabilities>
    >
  >;
export type StatisticControllerGetTopAssetsWithMostVulnerabilitiesQueryError =
  unknown;

export function useStatisticControllerGetTopAssetsWithMostVulnerabilities<
  TData = Awaited<
    ReturnType<typeof statisticControllerGetTopAssetsWithMostVulnerabilities>
  >,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof statisticControllerGetTopAssetsWithMostVulnerabilities
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof statisticControllerGetTopAssetsWithMostVulnerabilities
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof statisticControllerGetTopAssetsWithMostVulnerabilities
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetTopAssetsWithMostVulnerabilities<
  TData = Awaited<
    ReturnType<typeof statisticControllerGetTopAssetsWithMostVulnerabilities>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof statisticControllerGetTopAssetsWithMostVulnerabilities
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof statisticControllerGetTopAssetsWithMostVulnerabilities
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof statisticControllerGetTopAssetsWithMostVulnerabilities
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatisticControllerGetTopAssetsWithMostVulnerabilities<
  TData = Awaited<
    ReturnType<typeof statisticControllerGetTopAssetsWithMostVulnerabilities>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof statisticControllerGetTopAssetsWithMostVulnerabilities
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get top 10 assets with the most vulnerabilities in a workspace
 */

export function useStatisticControllerGetTopAssetsWithMostVulnerabilities<
  TData = Awaited<
    ReturnType<typeof statisticControllerGetTopAssetsWithMostVulnerabilities>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof statisticControllerGetTopAssetsWithMostVulnerabilities
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getStatisticControllerGetTopAssetsWithMostVulnerabilitiesQueryOptions(
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Initiates a vulnerability scan for a specified target, identifying potential security risks and vulnerabilities.
 * @summary Scan target
 */
export const vulnerabilitiesControllerScan = (
  scanDto: ScanDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    {
      url: `/api/vulnerabilities/scan`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: scanDto,
      signal,
    },
    options,
  );
};

export const getVulnerabilitiesControllerScanMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof vulnerabilitiesControllerScan>>,
    TError,
    { data: ScanDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof vulnerabilitiesControllerScan>>,
  TError,
  { data: ScanDto },
  TContext
> => {
  const mutationKey = ['vulnerabilitiesControllerScan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof vulnerabilitiesControllerScan>>,
    { data: ScanDto }
  > = (props) => {
    const { data } = props ?? {};

    return vulnerabilitiesControllerScan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type VulnerabilitiesControllerScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof vulnerabilitiesControllerScan>>
>;
export type VulnerabilitiesControllerScanMutationBody = ScanDto;
export type VulnerabilitiesControllerScanMutationError = unknown;

/**
 * @summary Scan target
 */
export const useVulnerabilitiesControllerScan = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof vulnerabilitiesControllerScan>>,
      TError,
      { data: ScanDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof vulnerabilitiesControllerScan>>,
  TError,
  { data: ScanDto },
  TContext
> => {
  const mutationOptions =
    getVulnerabilitiesControllerScanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a comprehensive list of security vulnerabilities identified across targets and assets, including detailed information about risks and remediation recommendations.
 * @summary Get vulnerabilities
 */
export const vulnerabilitiesControllerGetVulnerabilities = (
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyVulnerabilityDto>(
    { url: `/api/vulnerabilities`, method: 'GET', params, signal },
    options,
  );
};

export const getVulnerabilitiesControllerGetVulnerabilitiesInfiniteQueryKey = (
  params?: VulnerabilitiesControllerGetVulnerabilitiesParams,
) => {
  return [
    'infinite',
    `/api/vulnerabilities`,
    ...(params ? [params] : []),
  ] as const;
};

export const getVulnerabilitiesControllerGetVulnerabilitiesQueryKey = (
  params?: VulnerabilitiesControllerGetVulnerabilitiesParams,
) => {
  return [`/api/vulnerabilities`, ...(params ? [params] : [])] as const;
};

export const getVulnerabilitiesControllerGetVulnerabilitiesInfiniteQueryOptions =
  <
    TData = InfiniteData<
      Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
      VulnerabilitiesControllerGetVulnerabilitiesParams['page']
    >,
    TError = unknown,
  >(
    params: VulnerabilitiesControllerGetVulnerabilitiesParams,
    options?: {
      query?: Partial<
        UseInfiniteQueryOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          TError,
          TData,
          QueryKey,
          VulnerabilitiesControllerGetVulnerabilitiesParams['page']
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getVulnerabilitiesControllerGetVulnerabilitiesInfiniteQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
      QueryKey,
      VulnerabilitiesControllerGetVulnerabilitiesParams['page']
    > = ({ signal, pageParam }) =>
      vulnerabilitiesControllerGetVulnerabilities(
        { ...params, page: pageParam || params?.['page'] },
        requestOptions,
        signal,
      );

    return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
      TError,
      TData,
      QueryKey,
      VulnerabilitiesControllerGetVulnerabilitiesParams['page']
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type VulnerabilitiesControllerGetVulnerabilitiesInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>
  >;
export type VulnerabilitiesControllerGetVulnerabilitiesInfiniteQueryError =
  unknown;

export function useVulnerabilitiesControllerGetVulnerabilitiesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
    VulnerabilitiesControllerGetVulnerabilitiesParams['page']
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData,
        QueryKey,
        VulnerabilitiesControllerGetVulnerabilitiesParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          TError,
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilitiesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
    VulnerabilitiesControllerGetVulnerabilitiesParams['page']
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData,
        QueryKey,
        VulnerabilitiesControllerGetVulnerabilitiesParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          TError,
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilitiesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
    VulnerabilitiesControllerGetVulnerabilitiesParams['page']
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData,
        QueryKey,
        VulnerabilitiesControllerGetVulnerabilitiesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get vulnerabilities
 */

export function useVulnerabilitiesControllerGetVulnerabilitiesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
    VulnerabilitiesControllerGetVulnerabilitiesParams['page']
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData,
        QueryKey,
        VulnerabilitiesControllerGetVulnerabilitiesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getVulnerabilitiesControllerGetVulnerabilitiesInfiniteQueryOptions(
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVulnerabilitiesControllerGetVulnerabilitiesQueryOptions = <
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getVulnerabilitiesControllerGetVulnerabilitiesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>
  > = ({ signal }) =>
    vulnerabilitiesControllerGetVulnerabilities(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VulnerabilitiesControllerGetVulnerabilitiesQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>
  >;
export type VulnerabilitiesControllerGetVulnerabilitiesQueryError = unknown;

export function useVulnerabilitiesControllerGetVulnerabilities<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          TError,
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilities<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >,
          TError,
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilities<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get vulnerabilities
 */

export function useVulnerabilitiesControllerGetVulnerabilities<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilities>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getVulnerabilitiesControllerGetVulnerabilitiesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Provides aggregated statistical analysis of security vulnerabilities categorized by severity levels, enabling risk assessment and prioritization of remediation efforts.
 * @summary Get vulnerabilities statistics
 */
export const vulnerabilitiesControllerGetVulnerabilitiesStatistics = (
  params: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetVulnerabilitiesStatisticsResponseDto>(
    { url: `/api/vulnerabilities/statistics`, method: 'GET', params, signal },
    options,
  );
};

export const getVulnerabilitiesControllerGetVulnerabilitiesStatisticsQueryKey =
  (params?: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams) => {
    return [
      `/api/vulnerabilities/statistics`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getVulnerabilitiesControllerGetVulnerabilitiesStatisticsQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
    >,
    TError = unknown,
  >(
    params: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getVulnerabilitiesControllerGetVulnerabilitiesStatisticsQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
      >
    > = ({ signal }) =>
      vulnerabilitiesControllerGetVulnerabilitiesStatistics(
        params,
        requestOptions,
        signal,
      );

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type VulnerabilitiesControllerGetVulnerabilitiesStatisticsQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
    >
  >;
export type VulnerabilitiesControllerGetVulnerabilitiesStatisticsQueryError =
  unknown;

export function useVulnerabilitiesControllerGetVulnerabilitiesStatistics<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilitiesStatistics<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilitiesStatistics<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get vulnerabilities statistics
 */

export function useVulnerabilitiesControllerGetVulnerabilitiesStatistics<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics>
  >,
  TError = unknown,
>(
  params: VulnerabilitiesControllerGetVulnerabilitiesStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof vulnerabilitiesControllerGetVulnerabilitiesStatistics
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getVulnerabilitiesControllerGetVulnerabilitiesStatisticsQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves detailed information about a specific security vulnerability identified within the system, including its attributes, associated assets, and remediation guidance.
 * @summary Get vulnerability by id
 */
export const vulnerabilitiesControllerGetVulnerabilityById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Vulnerability>(
    { url: `/api/vulnerabilities/${id}`, method: 'GET', signal },
    options,
  );
};

export const getVulnerabilitiesControllerGetVulnerabilityByIdQueryKey = (
  id?: string,
) => {
  return [`/api/vulnerabilities/${id}`] as const;
};

export const getVulnerabilitiesControllerGetVulnerabilityByIdQueryOptions = <
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
  >,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getVulnerabilitiesControllerGetVulnerabilityByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>>
  > = ({ signal }) =>
    vulnerabilitiesControllerGetVulnerabilityById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VulnerabilitiesControllerGetVulnerabilityByIdQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>>
  >;
export type VulnerabilitiesControllerGetVulnerabilityByIdQueryError = unknown;

export function useVulnerabilitiesControllerGetVulnerabilityById<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
  >,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
          >,
          TError,
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilityById<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
  >,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
          >,
          TError,
          Awaited<
            ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVulnerabilitiesControllerGetVulnerabilityById<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
  >,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get vulnerability by id
 */

export function useVulnerabilitiesControllerGetVulnerabilityById<
  TData = Awaited<
    ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
  >,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof vulnerabilitiesControllerGetVulnerabilityById>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getVulnerabilitiesControllerGetVulnerabilityByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Dismisses multiple security vulnerabilities identified within the system, removing them from active tracking and analysis.
 * @summary Bulk dismiss vulnerabilities
 */
export const vulnerabilitiesControllerBulkDismissVulnerabilities = (
  bulkDismissVulnerabilitiesDto: BulkDismissVulnerabilitiesDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<VulnerabilitiesControllerBulkDismissVulnerabilities200>(
    {
      url: `/api/vulnerabilities/dismiss`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: bulkDismissVulnerabilitiesDto,
      signal,
    },
    options,
  );
};

export const getVulnerabilitiesControllerBulkDismissVulnerabilitiesMutationOptions =
  <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerBulkDismissVulnerabilities>
      >,
      TError,
      { data: BulkDismissVulnerabilitiesDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof vulnerabilitiesControllerBulkDismissVulnerabilities>
    >,
    TError,
    { data: BulkDismissVulnerabilitiesDto },
    TContext
  > => {
    const mutationKey = ['vulnerabilitiesControllerBulkDismissVulnerabilities'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerBulkDismissVulnerabilities>
      >,
      { data: BulkDismissVulnerabilitiesDto }
    > = (props) => {
      const { data } = props ?? {};

      return vulnerabilitiesControllerBulkDismissVulnerabilities(
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type VulnerabilitiesControllerBulkDismissVulnerabilitiesMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof vulnerabilitiesControllerBulkDismissVulnerabilities>
    >
  >;
export type VulnerabilitiesControllerBulkDismissVulnerabilitiesMutationBody =
  BulkDismissVulnerabilitiesDto;
export type VulnerabilitiesControllerBulkDismissVulnerabilitiesMutationError =
  unknown;

/**
 * @summary Bulk dismiss vulnerabilities
 */
export const useVulnerabilitiesControllerBulkDismissVulnerabilities = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerBulkDismissVulnerabilities>
      >,
      TError,
      { data: BulkDismissVulnerabilitiesDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof vulnerabilitiesControllerBulkDismissVulnerabilities>
  >,
  TError,
  { data: BulkDismissVulnerabilitiesDto },
  TContext
> => {
  const mutationOptions =
    getVulnerabilitiesControllerBulkDismissVulnerabilitiesMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Reopens multiple security vulnerabilities identified within the system, restoring them to active tracking and analysis.
 * @summary Bulk reopen vulnerabilities
 */
export const vulnerabilitiesControllerBulkReopenVulnerabilities = (
  bulkReopenVulnerabilitiesDto: BulkReopenVulnerabilitiesDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    {
      url: `/api/vulnerabilities/reopen`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: bulkReopenVulnerabilitiesDto,
      signal,
    },
    options,
  );
};

export const getVulnerabilitiesControllerBulkReopenVulnerabilitiesMutationOptions =
  <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerBulkReopenVulnerabilities>
      >,
      TError,
      { data: BulkReopenVulnerabilitiesDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof vulnerabilitiesControllerBulkReopenVulnerabilities>
    >,
    TError,
    { data: BulkReopenVulnerabilitiesDto },
    TContext
  > => {
    const mutationKey = ['vulnerabilitiesControllerBulkReopenVulnerabilities'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        'mutationKey' in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerBulkReopenVulnerabilities>
      >,
      { data: BulkReopenVulnerabilitiesDto }
    > = (props) => {
      const { data } = props ?? {};

      return vulnerabilitiesControllerBulkReopenVulnerabilities(
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type VulnerabilitiesControllerBulkReopenVulnerabilitiesMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof vulnerabilitiesControllerBulkReopenVulnerabilities>
    >
  >;
export type VulnerabilitiesControllerBulkReopenVulnerabilitiesMutationBody =
  BulkReopenVulnerabilitiesDto;
export type VulnerabilitiesControllerBulkReopenVulnerabilitiesMutationError =
  unknown;

/**
 * @summary Bulk reopen vulnerabilities
 */
export const useVulnerabilitiesControllerBulkReopenVulnerabilities = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof vulnerabilitiesControllerBulkReopenVulnerabilities>
      >,
      TError,
      { data: BulkReopenVulnerabilitiesDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof vulnerabilitiesControllerBulkReopenVulnerabilities>
  >,
  TError,
  { data: BulkReopenVulnerabilitiesDto },
  TContext
> => {
  const mutationOptions =
    getVulnerabilitiesControllerBulkReopenVulnerabilitiesMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Registers a new security assessment tool in the system with specified configuration and capabilities.
 * @summary Create a new tool
 */
export const toolsControllerCreateTool = (
  createToolDto: CreateToolDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Tool>(
    {
      url: `/api/tools`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createToolDto,
      signal,
    },
    options,
  );
};

export const getToolsControllerCreateToolMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toolsControllerCreateTool>>,
    TError,
    { data: CreateToolDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toolsControllerCreateTool>>,
  TError,
  { data: CreateToolDto },
  TContext
> => {
  const mutationKey = ['toolsControllerCreateTool'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toolsControllerCreateTool>>,
    { data: CreateToolDto }
  > = (props) => {
    const { data } = props ?? {};

    return toolsControllerCreateTool(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToolsControllerCreateToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerCreateTool>>
>;
export type ToolsControllerCreateToolMutationBody = CreateToolDto;
export type ToolsControllerCreateToolMutationError = unknown;

/**
 * @summary Create a new tool
 */
export const useToolsControllerCreateTool = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toolsControllerCreateTool>>,
      TError,
      { data: CreateToolDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toolsControllerCreateTool>>,
  TError,
  { data: CreateToolDto },
  TContext
> => {
  const mutationOptions = getToolsControllerCreateToolMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Fetches a paginated list of available security assessment tools in the system.
 * @summary Get tools
 */
export const toolsControllerGetManyTools = (
  params?: ToolsControllerGetManyToolsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyToolDto>(
    { url: `/api/tools`, method: 'GET', params, signal },
    options,
  );
};

export const getToolsControllerGetManyToolsInfiniteQueryKey = (
  params?: ToolsControllerGetManyToolsParams,
) => {
  return ['infinite', `/api/tools`, ...(params ? [params] : [])] as const;
};

export const getToolsControllerGetManyToolsQueryKey = (
  params?: ToolsControllerGetManyToolsParams,
) => {
  return [`/api/tools`, ...(params ? [params] : [])] as const;
};

export const getToolsControllerGetManyToolsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    ToolsControllerGetManyToolsParams['page']
  >,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData,
        QueryKey,
        ToolsControllerGetManyToolsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getToolsControllerGetManyToolsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    QueryKey,
    ToolsControllerGetManyToolsParams['page']
  > = ({ signal, pageParam }) =>
    toolsControllerGetManyTools(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    TError,
    TData,
    QueryKey,
    ToolsControllerGetManyToolsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ToolsControllerGetManyToolsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerGetManyTools>>
>;
export type ToolsControllerGetManyToolsInfiniteQueryError = unknown;

export function useToolsControllerGetManyToolsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    ToolsControllerGetManyToolsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | ToolsControllerGetManyToolsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData,
        QueryKey,
        ToolsControllerGetManyToolsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetManyToolsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    ToolsControllerGetManyToolsParams['page']
  >,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData,
        QueryKey,
        ToolsControllerGetManyToolsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetManyToolsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    ToolsControllerGetManyToolsParams['page']
  >,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData,
        QueryKey,
        ToolsControllerGetManyToolsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get tools
 */

export function useToolsControllerGetManyToolsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    ToolsControllerGetManyToolsParams['page']
  >,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData,
        QueryKey,
        ToolsControllerGetManyToolsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getToolsControllerGetManyToolsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getToolsControllerGetManyToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getToolsControllerGetManyToolsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>
  > = ({ signal }) =>
    toolsControllerGetManyTools(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ToolsControllerGetManyToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerGetManyTools>>
>;
export type ToolsControllerGetManyToolsQueryError = unknown;

export function useToolsControllerGetManyTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
  TError = unknown,
>(
  params: undefined | ToolsControllerGetManyToolsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetManyTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetManyTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetManyTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get tools
 */

export function useToolsControllerGetManyTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetManyToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetManyTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getToolsControllerGetManyToolsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Associates an existing security tool with a specific workspace for targeted assessments.
 * @summary Add tool to workspace
 */
export const toolsControllerAddToolToWorkspace = (
  addToolToWorkspaceDto: AddToolToWorkspaceDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<WorkspaceTool>(
    {
      url: `/api/tools/add-to-workspace`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addToolToWorkspaceDto,
      signal,
    },
    options,
  );
};

export const getToolsControllerAddToolToWorkspaceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toolsControllerAddToolToWorkspace>>,
    TError,
    { data: AddToolToWorkspaceDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toolsControllerAddToolToWorkspace>>,
  TError,
  { data: AddToolToWorkspaceDto },
  TContext
> => {
  const mutationKey = ['toolsControllerAddToolToWorkspace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toolsControllerAddToolToWorkspace>>,
    { data: AddToolToWorkspaceDto }
  > = (props) => {
    const { data } = props ?? {};

    return toolsControllerAddToolToWorkspace(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToolsControllerAddToolToWorkspaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerAddToolToWorkspace>>
>;
export type ToolsControllerAddToolToWorkspaceMutationBody =
  AddToolToWorkspaceDto;
export type ToolsControllerAddToolToWorkspaceMutationError = unknown;

/**
 * @summary Add tool to workspace
 */
export const useToolsControllerAddToolToWorkspace = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toolsControllerAddToolToWorkspace>>,
      TError,
      { data: AddToolToWorkspaceDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toolsControllerAddToolToWorkspace>>,
  TError,
  { data: AddToolToWorkspaceDto },
  TContext
> => {
  const mutationOptions =
    getToolsControllerAddToolToWorkspaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Installs a security tool to a specific workspace with duplicate checking to prevent conflicts.
 * @summary Install tool
 */
export const toolsControllerInstallTool = (
  installToolDto: InstallToolDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<WorkspaceTool>(
    {
      url: `/api/tools/install`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: installToolDto,
      signal,
    },
    options,
  );
};

export const getToolsControllerInstallToolMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toolsControllerInstallTool>>,
    TError,
    { data: InstallToolDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toolsControllerInstallTool>>,
  TError,
  { data: InstallToolDto },
  TContext
> => {
  const mutationKey = ['toolsControllerInstallTool'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toolsControllerInstallTool>>,
    { data: InstallToolDto }
  > = (props) => {
    const { data } = props ?? {};

    return toolsControllerInstallTool(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToolsControllerInstallToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerInstallTool>>
>;
export type ToolsControllerInstallToolMutationBody = InstallToolDto;
export type ToolsControllerInstallToolMutationError = unknown;

/**
 * @summary Install tool
 */
export const useToolsControllerInstallTool = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toolsControllerInstallTool>>,
      TError,
      { data: InstallToolDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toolsControllerInstallTool>>,
  TError,
  { data: InstallToolDto },
  TContext
> => {
  const mutationOptions = getToolsControllerInstallToolMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Removes a security tool from a specific workspace by deleting its association record.
 * @summary Uninstall tool
 */
export const toolsControllerUninstallTool = (
  installToolDto: InstallToolDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/tools/uninstall`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: installToolDto,
      signal,
    },
    options,
  );
};

export const getToolsControllerUninstallToolMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toolsControllerUninstallTool>>,
    TError,
    { data: InstallToolDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toolsControllerUninstallTool>>,
  TError,
  { data: InstallToolDto },
  TContext
> => {
  const mutationKey = ['toolsControllerUninstallTool'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toolsControllerUninstallTool>>,
    { data: InstallToolDto }
  > = (props) => {
    const { data } = props ?? {};

    return toolsControllerUninstallTool(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToolsControllerUninstallToolMutationResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerUninstallTool>>
>;
export type ToolsControllerUninstallToolMutationBody = InstallToolDto;
export type ToolsControllerUninstallToolMutationError = unknown;

/**
 * @summary Uninstall tool
 */
export const useToolsControllerUninstallTool = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toolsControllerUninstallTool>>,
      TError,
      { data: InstallToolDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toolsControllerUninstallTool>>,
  TError,
  { data: InstallToolDto },
  TContext
> => {
  const mutationOptions =
    getToolsControllerUninstallToolMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get built-in tools
 */
export const toolsControllerGetBuiltInTools = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyToolDto>(
    { url: `/api/tools/built-in-tools`, method: 'GET', signal },
    options,
  );
};

export const getToolsControllerGetBuiltInToolsQueryKey = () => {
  return [`/api/tools/built-in-tools`] as const;
};

export const getToolsControllerGetBuiltInToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getToolsControllerGetBuiltInToolsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>
  > = ({ signal }) => toolsControllerGetBuiltInTools(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ToolsControllerGetBuiltInToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>
>;
export type ToolsControllerGetBuiltInToolsQueryError = unknown;

export function useToolsControllerGetBuiltInTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetBuiltInTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetBuiltInTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get built-in tools
 */

export function useToolsControllerGetBuiltInTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetBuiltInTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getToolsControllerGetBuiltInToolsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetches all security tools installed in a specific workspace, including built-in tools.
 * @summary Get installed tools for a workspace
 */
export const toolsControllerGetInstalledTools = (
  params?: ToolsControllerGetInstalledToolsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyToolDto>(
    { url: `/api/tools/installed`, method: 'GET', params, signal },
    options,
  );
};

export const getToolsControllerGetInstalledToolsQueryKey = (
  params?: ToolsControllerGetInstalledToolsParams,
) => {
  return [`/api/tools/installed`, ...(params ? [params] : [])] as const;
};

export const getToolsControllerGetInstalledToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetInstalledToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getToolsControllerGetInstalledToolsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>
  > = ({ signal }) =>
    toolsControllerGetInstalledTools(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ToolsControllerGetInstalledToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>
>;
export type ToolsControllerGetInstalledToolsQueryError = unknown;

export function useToolsControllerGetInstalledTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
  TError = unknown,
>(
  params: undefined | ToolsControllerGetInstalledToolsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetInstalledTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetInstalledToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetInstalledTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetInstalledToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get installed tools for a workspace
 */

export function useToolsControllerGetInstalledTools<
  TData = Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
  TError = unknown,
>(
  params?: ToolsControllerGetInstalledToolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetInstalledTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getToolsControllerGetInstalledToolsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetches detailed information about a specific security tool using its unique identifier.
 * @summary Get tool by ID
 */
export const toolsControllerGetToolById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Tool>(
    { url: `/api/tools/${id}`, method: 'GET', signal },
    options,
  );
};

export const getToolsControllerGetToolByIdQueryKey = (id?: string) => {
  return [`/api/tools/${id}`] as const;
};

export const getToolsControllerGetToolByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof toolsControllerGetToolById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getToolsControllerGetToolByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof toolsControllerGetToolById>>
  > = ({ signal }) => toolsControllerGetToolById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof toolsControllerGetToolById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ToolsControllerGetToolByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerGetToolById>>
>;
export type ToolsControllerGetToolByIdQueryError = unknown;

export function useToolsControllerGetToolById<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetToolById>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetToolById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetToolById<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetToolById>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetToolById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetToolById<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get tool by ID
 */

export function useToolsControllerGetToolById<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getToolsControllerGetToolByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the authentication API key for accessing the specified security tool.
 * @summary Get tool API key
 */
export const toolsControllerGetToolApiKey = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetApiKeyResponseDto>(
    { url: `/api/tools/${id}/api-key`, method: 'GET', signal },
    options,
  );
};

export const getToolsControllerGetToolApiKeyQueryKey = (id?: string) => {
  return [`/api/tools/${id}/api-key`] as const;
};

export const getToolsControllerGetToolApiKeyQueryOptions = <
  TData = Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getToolsControllerGetToolApiKeyQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>
  > = ({ signal }) => toolsControllerGetToolApiKey(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ToolsControllerGetToolApiKeyQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>
>;
export type ToolsControllerGetToolApiKeyQueryError = unknown;

export function useToolsControllerGetToolApiKey<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetToolApiKey<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
          TError,
          Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useToolsControllerGetToolApiKey<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get tool API key
 */

export function useToolsControllerGetToolApiKey<
  TData = Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof toolsControllerGetToolApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getToolsControllerGetToolApiKeyQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Regenerates a new API key for the specified security tool, invalidating the previous key.
 * @summary Rotate tool API key
 */
export const toolsControllerRotateToolApiKey = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetApiKeyResponseDto>(
    { url: `/api/tools/${id}/api-key/rotate`, method: 'POST', signal },
    options,
  );
};

export const getToolsControllerRotateToolApiKeyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toolsControllerRotateToolApiKey>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toolsControllerRotateToolApiKey>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['toolsControllerRotateToolApiKey'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toolsControllerRotateToolApiKey>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return toolsControllerRotateToolApiKey(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToolsControllerRotateToolApiKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof toolsControllerRotateToolApiKey>>
>;

export type ToolsControllerRotateToolApiKeyMutationError = unknown;

/**
 * @summary Rotate tool API key
 */
export const useToolsControllerRotateToolApiKey = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toolsControllerRotateToolApiKey>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toolsControllerRotateToolApiKey>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getToolsControllerRotateToolApiKeyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get all providers with pagination, filtered by owner
 * @summary Get all providers
 */
export const providersControllerGetManyProviders = (
  params?: ProvidersControllerGetManyProvidersParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyToolProviderDto>(
    { url: `/api/providers`, method: 'GET', params, signal },
    options,
  );
};

export const getProvidersControllerGetManyProvidersInfiniteQueryKey = (
  params?: ProvidersControllerGetManyProvidersParams,
) => {
  return ['infinite', `/api/providers`, ...(params ? [params] : [])] as const;
};

export const getProvidersControllerGetManyProvidersQueryKey = (
  params?: ProvidersControllerGetManyProvidersParams,
) => {
  return [`/api/providers`, ...(params ? [params] : [])] as const;
};

export const getProvidersControllerGetManyProvidersInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    ProvidersControllerGetManyProvidersParams['page']
  >,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData,
        QueryKey,
        ProvidersControllerGetManyProvidersParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getProvidersControllerGetManyProvidersInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    QueryKey,
    ProvidersControllerGetManyProvidersParams['page']
  > = ({ signal, pageParam }) =>
    providersControllerGetManyProviders(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    TError,
    TData,
    QueryKey,
    ProvidersControllerGetManyProvidersParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProvidersControllerGetManyProvidersInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof providersControllerGetManyProviders>>>;
export type ProvidersControllerGetManyProvidersInfiniteQueryError = unknown;

export function useProvidersControllerGetManyProvidersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    ProvidersControllerGetManyProvidersParams['page']
  >,
  TError = unknown,
>(
  params: undefined | ProvidersControllerGetManyProvidersParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData,
        QueryKey,
        ProvidersControllerGetManyProvidersParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
          TError,
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProvidersControllerGetManyProvidersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    ProvidersControllerGetManyProvidersParams['page']
  >,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData,
        QueryKey,
        ProvidersControllerGetManyProvidersParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
          TError,
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProvidersControllerGetManyProvidersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    ProvidersControllerGetManyProvidersParams['page']
  >,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData,
        QueryKey,
        ProvidersControllerGetManyProvidersParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all providers
 */

export function useProvidersControllerGetManyProvidersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    ProvidersControllerGetManyProvidersParams['page']
  >,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData,
        QueryKey,
        ProvidersControllerGetManyProvidersParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getProvidersControllerGetManyProvidersInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getProvidersControllerGetManyProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getProvidersControllerGetManyProvidersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>
  > = ({ signal }) =>
    providersControllerGetManyProviders(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProvidersControllerGetManyProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof providersControllerGetManyProviders>>
>;
export type ProvidersControllerGetManyProvidersQueryError = unknown;

export function useProvidersControllerGetManyProviders<
  TData = Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
  TError = unknown,
>(
  params: undefined | ProvidersControllerGetManyProvidersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
          TError,
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProvidersControllerGetManyProviders<
  TData = Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
          TError,
          Awaited<ReturnType<typeof providersControllerGetManyProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProvidersControllerGetManyProviders<
  TData = Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all providers
 */

export function useProvidersControllerGetManyProviders<
  TData = Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
  TError = unknown,
>(
  params?: ProvidersControllerGetManyProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetManyProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getProvidersControllerGetManyProvidersQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new provider
 * @summary Create a new provider
 */
export const providersControllerCreateProvider = (
  createProviderDto: CreateProviderDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<ToolProvider>(
    {
      url: `/api/providers`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createProviderDto,
      signal,
    },
    options,
  );
};

export const getProvidersControllerCreateProviderMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersControllerCreateProvider>>,
    TError,
    { data: CreateProviderDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof providersControllerCreateProvider>>,
  TError,
  { data: CreateProviderDto },
  TContext
> => {
  const mutationKey = ['providersControllerCreateProvider'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersControllerCreateProvider>>,
    { data: CreateProviderDto }
  > = (props) => {
    const { data } = props ?? {};

    return providersControllerCreateProvider(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProvidersControllerCreateProviderMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersControllerCreateProvider>>
>;
export type ProvidersControllerCreateProviderMutationBody = CreateProviderDto;
export type ProvidersControllerCreateProviderMutationError = unknown;

/**
 * @summary Create a new provider
 */
export const useProvidersControllerCreateProvider = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof providersControllerCreateProvider>>,
      TError,
      { data: CreateProviderDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof providersControllerCreateProvider>>,
  TError,
  { data: CreateProviderDto },
  TContext
> => {
  const mutationOptions =
    getProvidersControllerCreateProviderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get detailed information about a specific provider
 * @summary Get a provider by ID
 */
export const providersControllerGetProvider = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<ToolProvider>(
    { url: `/api/providers/${id}`, method: 'GET', signal },
    options,
  );
};

export const getProvidersControllerGetProviderQueryKey = (id?: string) => {
  return [`/api/providers/${id}`] as const;
};

export const getProvidersControllerGetProviderQueryOptions = <
  TData = Awaited<ReturnType<typeof providersControllerGetProvider>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetProvider>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getProvidersControllerGetProviderQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersControllerGetProvider>>
  > = ({ signal }) =>
    providersControllerGetProvider(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof providersControllerGetProvider>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProvidersControllerGetProviderQueryResult = NonNullable<
  Awaited<ReturnType<typeof providersControllerGetProvider>>
>;
export type ProvidersControllerGetProviderQueryError = unknown;

export function useProvidersControllerGetProvider<
  TData = Awaited<ReturnType<typeof providersControllerGetProvider>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetProvider>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof providersControllerGetProvider>>,
          TError,
          Awaited<ReturnType<typeof providersControllerGetProvider>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProvidersControllerGetProvider<
  TData = Awaited<ReturnType<typeof providersControllerGetProvider>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetProvider>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof providersControllerGetProvider>>,
          TError,
          Awaited<ReturnType<typeof providersControllerGetProvider>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProvidersControllerGetProvider<
  TData = Awaited<ReturnType<typeof providersControllerGetProvider>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetProvider>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a provider by ID
 */

export function useProvidersControllerGetProvider<
  TData = Awaited<ReturnType<typeof providersControllerGetProvider>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersControllerGetProvider>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getProvidersControllerGetProviderQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update an existing provider by ID
 * @summary Update a provider
 */
export const providersControllerUpdateProvider = (
  id: string,
  updateProviderDto: UpdateProviderDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<ToolProvider>(
    {
      url: `/api/providers/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateProviderDto,
    },
    options,
  );
};

export const getProvidersControllerUpdateProviderMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersControllerUpdateProvider>>,
    TError,
    { id: string; data: UpdateProviderDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof providersControllerUpdateProvider>>,
  TError,
  { id: string; data: UpdateProviderDto },
  TContext
> => {
  const mutationKey = ['providersControllerUpdateProvider'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersControllerUpdateProvider>>,
    { id: string; data: UpdateProviderDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return providersControllerUpdateProvider(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProvidersControllerUpdateProviderMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersControllerUpdateProvider>>
>;
export type ProvidersControllerUpdateProviderMutationBody = UpdateProviderDto;
export type ProvidersControllerUpdateProviderMutationError = unknown;

/**
 * @summary Update a provider
 */
export const useProvidersControllerUpdateProvider = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof providersControllerUpdateProvider>>,
      TError,
      { id: string; data: UpdateProviderDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof providersControllerUpdateProvider>>,
  TError,
  { id: string; data: UpdateProviderDto },
  TContext
> => {
  const mutationOptions =
    getProvidersControllerUpdateProviderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Soft delete a provider by ID
 * @summary Delete a provider
 */
export const providersControllerDeleteProvider = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/providers/${id}`, method: 'DELETE' },
    options,
  );
};

export const getProvidersControllerDeleteProviderMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersControllerDeleteProvider>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof providersControllerDeleteProvider>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['providersControllerDeleteProvider'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersControllerDeleteProvider>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return providersControllerDeleteProvider(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProvidersControllerDeleteProviderMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersControllerDeleteProvider>>
>;

export type ProvidersControllerDeleteProviderMutationError = unknown;

/**
 * @summary Delete a provider
 */
export const useProvidersControllerDeleteProvider = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof providersControllerDeleteProvider>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof providersControllerDeleteProvider>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getProvidersControllerDeleteProviderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new template with file stored in the storage
 * @summary Create a new templates
 */
export const templatesControllerCreateTemplate = (
  createTemplateDTO: CreateTemplateDTO,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Template>(
    {
      url: `/api/templates`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createTemplateDTO,
      signal,
    },
    options,
  );
};

export const getTemplatesControllerCreateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof templatesControllerCreateTemplate>>,
    TError,
    { data: CreateTemplateDTO },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof templatesControllerCreateTemplate>>,
  TError,
  { data: CreateTemplateDTO },
  TContext
> => {
  const mutationKey = ['templatesControllerCreateTemplate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof templatesControllerCreateTemplate>>,
    { data: CreateTemplateDTO }
  > = (props) => {
    const { data } = props ?? {};

    return templatesControllerCreateTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TemplatesControllerCreateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerCreateTemplate>>
>;
export type TemplatesControllerCreateTemplateMutationBody = CreateTemplateDTO;
export type TemplatesControllerCreateTemplateMutationError = unknown;

/**
 * @summary Create a new templates
 */
export const useTemplatesControllerCreateTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof templatesControllerCreateTemplate>>,
      TError,
      { data: CreateTemplateDTO },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof templatesControllerCreateTemplate>>,
  TError,
  { data: CreateTemplateDTO },
  TContext
> => {
  const mutationOptions =
    getTemplatesControllerCreateTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve all templates in a workspace
 * @summary Get all templates
 */
export const templatesControllerGetAllTemplates = (
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyTemplateDto>(
    { url: `/api/templates`, method: 'GET', params, signal },
    options,
  );
};

export const getTemplatesControllerGetAllTemplatesInfiniteQueryKey = (
  params?: TemplatesControllerGetAllTemplatesParams,
) => {
  return ['infinite', `/api/templates`, ...(params ? [params] : [])] as const;
};

export const getTemplatesControllerGetAllTemplatesQueryKey = (
  params?: TemplatesControllerGetAllTemplatesParams,
) => {
  return [`/api/templates`, ...(params ? [params] : [])] as const;
};

export const getTemplatesControllerGetAllTemplatesInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TemplatesControllerGetAllTemplatesParams['page']
  >,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData,
        QueryKey,
        TemplatesControllerGetAllTemplatesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTemplatesControllerGetAllTemplatesInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    QueryKey,
    TemplatesControllerGetAllTemplatesParams['page']
  > = ({ signal, pageParam }) =>
    templatesControllerGetAllTemplates(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TError,
    TData,
    QueryKey,
    TemplatesControllerGetAllTemplatesParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TemplatesControllerGetAllTemplatesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>
>;
export type TemplatesControllerGetAllTemplatesInfiniteQueryError = unknown;

export function useTemplatesControllerGetAllTemplatesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TemplatesControllerGetAllTemplatesParams['page']
  >,
  TError = unknown,
>(
  params: undefined | TemplatesControllerGetAllTemplatesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData,
        QueryKey,
        TemplatesControllerGetAllTemplatesParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
          TError,
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTemplatesControllerGetAllTemplatesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TemplatesControllerGetAllTemplatesParams['page']
  >,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData,
        QueryKey,
        TemplatesControllerGetAllTemplatesParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
          TError,
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTemplatesControllerGetAllTemplatesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TemplatesControllerGetAllTemplatesParams['page']
  >,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData,
        QueryKey,
        TemplatesControllerGetAllTemplatesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all templates
 */

export function useTemplatesControllerGetAllTemplatesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TemplatesControllerGetAllTemplatesParams['page']
  >,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData,
        QueryKey,
        TemplatesControllerGetAllTemplatesParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getTemplatesControllerGetAllTemplatesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplatesControllerGetAllTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTemplatesControllerGetAllTemplatesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>
  > = ({ signal }) =>
    templatesControllerGetAllTemplates(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TemplatesControllerGetAllTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>
>;
export type TemplatesControllerGetAllTemplatesQueryError = unknown;

export function useTemplatesControllerGetAllTemplates<
  TData = Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
  TError = unknown,
>(
  params: undefined | TemplatesControllerGetAllTemplatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
          TError,
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTemplatesControllerGetAllTemplates<
  TData = Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
          TError,
          Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTemplatesControllerGetAllTemplates<
  TData = Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all templates
 */

export function useTemplatesControllerGetAllTemplates<
  TData = Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
  TError = unknown,
>(
  params?: TemplatesControllerGetAllTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetAllTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTemplatesControllerGetAllTemplatesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Upload a template to the storage
 * @summary Template upload
 */
export const templatesControllerUploadFile = (
  uploadTemplateDTO: UploadTemplateDTO,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<UploadTemplateResponseDTO>(
    {
      url: `/api/templates/upload`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: uploadTemplateDTO,
      signal,
    },
    options,
  );
};

export const getTemplatesControllerUploadFileMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof templatesControllerUploadFile>>,
    TError,
    { data: UploadTemplateDTO },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof templatesControllerUploadFile>>,
  TError,
  { data: UploadTemplateDTO },
  TContext
> => {
  const mutationKey = ['templatesControllerUploadFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof templatesControllerUploadFile>>,
    { data: UploadTemplateDTO }
  > = (props) => {
    const { data } = props ?? {};

    return templatesControllerUploadFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TemplatesControllerUploadFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerUploadFile>>
>;
export type TemplatesControllerUploadFileMutationBody = UploadTemplateDTO;
export type TemplatesControllerUploadFileMutationError = unknown;

/**
 * @summary Template upload
 */
export const useTemplatesControllerUploadFile = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof templatesControllerUploadFile>>,
      TError,
      { data: UploadTemplateDTO },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof templatesControllerUploadFile>>,
  TError,
  { data: UploadTemplateDTO },
  TContext
> => {
  const mutationOptions =
    getTemplatesControllerUploadFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Rename the display filename of a template
 * @summary Rename a template file
 */
export const templatesControllerRenameFile = (
  templateId: string,
  renameTemplateDTO: RenameTemplateDTO,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<Template>(
    {
      url: `/api/templates/${templateId}/rename`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: renameTemplateDTO,
    },
    options,
  );
};

export const getTemplatesControllerRenameFileMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof templatesControllerRenameFile>>,
    TError,
    { templateId: string; data: RenameTemplateDTO },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof templatesControllerRenameFile>>,
  TError,
  { templateId: string; data: RenameTemplateDTO },
  TContext
> => {
  const mutationKey = ['templatesControllerRenameFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof templatesControllerRenameFile>>,
    { templateId: string; data: RenameTemplateDTO }
  > = (props) => {
    const { templateId, data } = props ?? {};

    return templatesControllerRenameFile(templateId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TemplatesControllerRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerRenameFile>>
>;
export type TemplatesControllerRenameFileMutationBody = RenameTemplateDTO;
export type TemplatesControllerRenameFileMutationError = unknown;

/**
 * @summary Rename a template file
 */
export const useTemplatesControllerRenameFile = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof templatesControllerRenameFile>>,
      TError,
      { templateId: string; data: RenameTemplateDTO },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof templatesControllerRenameFile>>,
  TError,
  { templateId: string; data: RenameTemplateDTO },
  TContext
> => {
  const mutationOptions =
    getTemplatesControllerRenameFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a template by its ID
 * @summary Get a template by ID
 */
export const templatesControllerGetTemplateById = (
  templateId: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Template>(
    { url: `/api/templates/${templateId}`, method: 'GET', signal },
    options,
  );
};

export const getTemplatesControllerGetTemplateByIdQueryKey = (
  templateId?: string,
) => {
  return [`/api/templates/${templateId}`] as const;
};

export const getTemplatesControllerGetTemplateByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTemplatesControllerGetTemplateByIdQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof templatesControllerGetTemplateById>>
  > = ({ signal }) =>
    templatesControllerGetTemplateById(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TemplatesControllerGetTemplateByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerGetTemplateById>>
>;
export type TemplatesControllerGetTemplateByIdQueryError = unknown;

export function useTemplatesControllerGetTemplateById<
  TData = Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
          TError,
          Awaited<ReturnType<typeof templatesControllerGetTemplateById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTemplatesControllerGetTemplateById<
  TData = Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
          TError,
          Awaited<ReturnType<typeof templatesControllerGetTemplateById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTemplatesControllerGetTemplateById<
  TData = Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a template by ID
 */

export function useTemplatesControllerGetTemplateById<
  TData = Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof templatesControllerGetTemplateById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTemplatesControllerGetTemplateByIdQueryOptions(
    templateId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a template and its associated file from storage
 * @summary Delete a template
 */
export const templatesControllerDeleteTemplate = (
  templateId: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/templates/${templateId}`, method: 'DELETE' },
    options,
  );
};

export const getTemplatesControllerDeleteTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof templatesControllerDeleteTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof templatesControllerDeleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationKey = ['templatesControllerDeleteTemplate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof templatesControllerDeleteTemplate>>,
    { templateId: string }
  > = (props) => {
    const { templateId } = props ?? {};

    return templatesControllerDeleteTemplate(templateId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TemplatesControllerDeleteTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerDeleteTemplate>>
>;

export type TemplatesControllerDeleteTemplateMutationError = unknown;

/**
 * @summary Delete a template
 */
export const useTemplatesControllerDeleteTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof templatesControllerDeleteTemplate>>,
      TError,
      { templateId: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof templatesControllerDeleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationOptions =
    getTemplatesControllerDeleteTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Run a template and create a job
 * @summary Run a template
 */
export const templatesControllerRunTemplate = (
  runTemplateDto: RunTemplateDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Job>(
    {
      url: `/api/templates/run`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: runTemplateDto,
      signal,
    },
    options,
  );
};

export const getTemplatesControllerRunTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof templatesControllerRunTemplate>>,
    TError,
    { data: RunTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof templatesControllerRunTemplate>>,
  TError,
  { data: RunTemplateDto },
  TContext
> => {
  const mutationKey = ['templatesControllerRunTemplate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof templatesControllerRunTemplate>>,
    { data: RunTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return templatesControllerRunTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TemplatesControllerRunTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof templatesControllerRunTemplate>>
>;
export type TemplatesControllerRunTemplateMutationBody = RunTemplateDto;
export type TemplatesControllerRunTemplateMutationError = unknown;

/**
 * @summary Run a template
 */
export const useTemplatesControllerRunTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof templatesControllerRunTemplate>>,
      TError,
      { data: RunTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof templatesControllerRunTemplate>>,
  TError,
  { data: RunTemplateDto },
  TContext
> => {
  const mutationOptions =
    getTemplatesControllerRunTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all asset groups with optional filtering and pagination.
 * @summary Get all asset groups
 */
export const assetGroupControllerGetAll = (
  params?: AssetGroupControllerGetAllParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyAssetGroupDto>(
    { url: `/api/asset-group`, method: 'GET', params, signal },
    options,
  );
};

export const getAssetGroupControllerGetAllInfiniteQueryKey = (
  params?: AssetGroupControllerGetAllParams,
) => {
  return ['infinite', `/api/asset-group`, ...(params ? [params] : [])] as const;
};

export const getAssetGroupControllerGetAllQueryKey = (
  params?: AssetGroupControllerGetAllParams,
) => {
  return [`/api/asset-group`, ...(params ? [params] : [])] as const;
};

export const getAssetGroupControllerGetAllInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    AssetGroupControllerGetAllParams['page']
  >,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAllParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetGroupControllerGetAllInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    QueryKey,
    AssetGroupControllerGetAllParams['page']
  > = ({ signal, pageParam }) =>
    assetGroupControllerGetAll(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    TError,
    TData,
    QueryKey,
    AssetGroupControllerGetAllParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetAllInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerGetAll>>
>;
export type AssetGroupControllerGetAllInfiniteQueryError = unknown;

export function useAssetGroupControllerGetAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    AssetGroupControllerGetAllParams['page']
  >,
  TError = unknown,
>(
  params: undefined | AssetGroupControllerGetAllParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAllParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
          TError,
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    AssetGroupControllerGetAllParams['page']
  >,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAllParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
          TError,
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    AssetGroupControllerGetAllParams['page']
  >,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAllParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all asset groups
 */

export function useAssetGroupControllerGetAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    AssetGroupControllerGetAllParams['page']
  >,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAllParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetGroupControllerGetAllInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetGroupControllerGetAllQueryOptions = <
  TData = Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetGroupControllerGetAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>
  > = ({ signal }) =>
    assetGroupControllerGetAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerGetAll>>
>;
export type AssetGroupControllerGetAllQueryError = unknown;

export function useAssetGroupControllerGetAll<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
  TError = unknown,
>(
  params: undefined | AssetGroupControllerGetAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
          TError,
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAll<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
          TError,
          Awaited<ReturnType<typeof assetGroupControllerGetAll>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAll<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all asset groups
 */

export function useAssetGroupControllerGetAll<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
  TError = unknown,
>(
  params?: AssetGroupControllerGetAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetGroupControllerGetAllQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new asset group.
 * @summary Create asset group
 */
export const assetGroupControllerCreate = (
  createAssetGroupDto: CreateAssetGroupDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AssetGroup>(
    {
      url: `/api/asset-group`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createAssetGroupDto,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerCreate>>,
    TError,
    { data: CreateAssetGroupDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerCreate>>,
  TError,
  { data: CreateAssetGroupDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerCreate>>,
    { data: CreateAssetGroupDto }
  > = (props) => {
    const { data } = props ?? {};

    return assetGroupControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerCreate>>
>;
export type AssetGroupControllerCreateMutationBody = CreateAssetGroupDto;
export type AssetGroupControllerCreateMutationError = unknown;

/**
 * @summary Create asset group
 */
export const useAssetGroupControllerCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerCreate>>,
      TError,
      { data: CreateAssetGroupDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerCreate>>,
  TError,
  { data: CreateAssetGroupDto },
  TContext
> => {
  const mutationOptions = getAssetGroupControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Fetches a specific asset group by its unique identifier.
 * @summary Get asset group by ID
 */
export const assetGroupControllerGetById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AssetGroup>(
    { url: `/api/asset-group/${id}`, method: 'GET', signal },
    options,
  );
};

export const getAssetGroupControllerGetByIdQueryKey = (id?: string) => {
  return [`/api/asset-group/${id}`] as const;
};

export const getAssetGroupControllerGetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof assetGroupControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetGroupControllerGetByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetById>>
  > = ({ signal }) => assetGroupControllerGetById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerGetById>>
>;
export type AssetGroupControllerGetByIdQueryError = unknown;

export function useAssetGroupControllerGetById<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetGroupControllerGetById>>,
          TError,
          Awaited<ReturnType<typeof assetGroupControllerGetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetById<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetGroupControllerGetById>>,
          TError,
          Awaited<ReturnType<typeof assetGroupControllerGetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetById<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get asset group by ID
 */

export function useAssetGroupControllerGetById<
  TData = Awaited<ReturnType<typeof assetGroupControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof assetGroupControllerGetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAssetGroupControllerGetByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an existing asset group by ID.
 * @summary Update asset group
 */
export const assetGroupControllerUpdateAssetGroupById = (
  id: string,
  updateAssetGroupDto: UpdateAssetGroupDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AssetGroup>(
    {
      url: `/api/asset-group/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateAssetGroupDto,
    },
    options,
  );
};

export const getAssetGroupControllerUpdateAssetGroupByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupById>>,
    TError,
    { id: string; data: UpdateAssetGroupDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupById>>,
  TError,
  { id: string; data: UpdateAssetGroupDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerUpdateAssetGroupById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupById>>,
    { id: string; data: UpdateAssetGroupDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return assetGroupControllerUpdateAssetGroupById(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerUpdateAssetGroupByIdMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupById>>
  >;
export type AssetGroupControllerUpdateAssetGroupByIdMutationBody =
  UpdateAssetGroupDto;
export type AssetGroupControllerUpdateAssetGroupByIdMutationError = unknown;

/**
 * @summary Update asset group
 */
export const useAssetGroupControllerUpdateAssetGroupById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupById>>,
      TError,
      { id: string; data: UpdateAssetGroupDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupById>>,
  TError,
  { id: string; data: UpdateAssetGroupDto },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerUpdateAssetGroupByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Permanently removes an asset group.
 * @summary Delete asset group
 */
export const assetGroupControllerDelete = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/asset-group/${id}`, method: 'DELETE' },
    options,
  );
};

export const getAssetGroupControllerDeleteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['assetGroupControllerDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return assetGroupControllerDelete(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerDelete>>
>;

export type AssetGroupControllerDeleteMutationError = unknown;

/**
 * @summary Delete asset group
 */
export const useAssetGroupControllerDelete = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerDelete>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getAssetGroupControllerDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Associates multiple workflows with the specified asset group.
 * @summary Add multiple workflows to asset group
 */
export const assetGroupControllerAddManyWorkflows = (
  groupId: string,
  addManyWorkflowsToAssetGroupDto: AddManyWorkflowsToAssetGroupDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/asset-group/${groupId}/workflows`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addManyWorkflowsToAssetGroupDto,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerAddManyWorkflowsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerAddManyWorkflows>>,
    TError,
    { groupId: string; data: AddManyWorkflowsToAssetGroupDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerAddManyWorkflows>>,
  TError,
  { groupId: string; data: AddManyWorkflowsToAssetGroupDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerAddManyWorkflows'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerAddManyWorkflows>>,
    { groupId: string; data: AddManyWorkflowsToAssetGroupDto }
  > = (props) => {
    const { groupId, data } = props ?? {};

    return assetGroupControllerAddManyWorkflows(groupId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerAddManyWorkflowsMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerAddManyWorkflows>>
>;
export type AssetGroupControllerAddManyWorkflowsMutationBody =
  AddManyWorkflowsToAssetGroupDto;
export type AssetGroupControllerAddManyWorkflowsMutationError = unknown;

/**
 * @summary Add multiple workflows to asset group
 */
export const useAssetGroupControllerAddManyWorkflows = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerAddManyWorkflows>>,
      TError,
      { groupId: string; data: AddManyWorkflowsToAssetGroupDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerAddManyWorkflows>>,
  TError,
  { groupId: string; data: AddManyWorkflowsToAssetGroupDto },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerAddManyWorkflowsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Disassociates multiple workflows from the asset group.
 * @summary Remove multiple workflows from asset group
 */
export const assetGroupControllerRemoveManyWorkflows = (
  groupId: string,
  removeManyWorkflowsFromAssetGroupDto: RemoveManyWorkflowsFromAssetGroupDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/asset-group/${groupId}/workflows`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: removeManyWorkflowsFromAssetGroupDto,
    },
    options,
  );
};

export const getAssetGroupControllerRemoveManyWorkflowsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerRemoveManyWorkflows>>,
    TError,
    { groupId: string; data: RemoveManyWorkflowsFromAssetGroupDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerRemoveManyWorkflows>>,
  TError,
  { groupId: string; data: RemoveManyWorkflowsFromAssetGroupDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerRemoveManyWorkflows'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerRemoveManyWorkflows>>,
    { groupId: string; data: RemoveManyWorkflowsFromAssetGroupDto }
  > = (props) => {
    const { groupId, data } = props ?? {};

    return assetGroupControllerRemoveManyWorkflows(
      groupId,
      data,
      requestOptions,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerRemoveManyWorkflowsMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerRemoveManyWorkflows>>
>;
export type AssetGroupControllerRemoveManyWorkflowsMutationBody =
  RemoveManyWorkflowsFromAssetGroupDto;
export type AssetGroupControllerRemoveManyWorkflowsMutationError = unknown;

/**
 * @summary Remove multiple workflows from asset group
 */
export const useAssetGroupControllerRemoveManyWorkflows = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerRemoveManyWorkflows>>,
      TError,
      { groupId: string; data: RemoveManyWorkflowsFromAssetGroupDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerRemoveManyWorkflows>>,
  TError,
  { groupId: string; data: RemoveManyWorkflowsFromAssetGroupDto },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerRemoveManyWorkflowsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Associates multiple assets with the specified asset group.
 * @summary Add multiple assets to asset group
 */
export const assetGroupControllerAddManyAssets = (
  groupId: string,
  addManyAssetsToAssetGroupDto: AddManyAssetsToAssetGroupDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/asset-group/${groupId}/assets`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addManyAssetsToAssetGroupDto,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerAddManyAssetsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerAddManyAssets>>,
    TError,
    { groupId: string; data: AddManyAssetsToAssetGroupDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerAddManyAssets>>,
  TError,
  { groupId: string; data: AddManyAssetsToAssetGroupDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerAddManyAssets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerAddManyAssets>>,
    { groupId: string; data: AddManyAssetsToAssetGroupDto }
  > = (props) => {
    const { groupId, data } = props ?? {};

    return assetGroupControllerAddManyAssets(groupId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerAddManyAssetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerAddManyAssets>>
>;
export type AssetGroupControllerAddManyAssetsMutationBody =
  AddManyAssetsToAssetGroupDto;
export type AssetGroupControllerAddManyAssetsMutationError = unknown;

/**
 * @summary Add multiple assets to asset group
 */
export const useAssetGroupControllerAddManyAssets = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerAddManyAssets>>,
      TError,
      { groupId: string; data: AddManyAssetsToAssetGroupDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerAddManyAssets>>,
  TError,
  { groupId: string; data: AddManyAssetsToAssetGroupDto },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerAddManyAssetsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Disassociates multiple assets from the asset group.
 * @summary Remove multiple assets from asset group
 */
export const assetGroupControllerRemoveManyAssets = (
  groupId: string,
  removeManyAssetsFromAssetGroupDto: RemoveManyAssetsFromAssetGroupDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/asset-group/${groupId}/assets`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: removeManyAssetsFromAssetGroupDto,
    },
    options,
  );
};

export const getAssetGroupControllerRemoveManyAssetsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerRemoveManyAssets>>,
    TError,
    { groupId: string; data: RemoveManyAssetsFromAssetGroupDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerRemoveManyAssets>>,
  TError,
  { groupId: string; data: RemoveManyAssetsFromAssetGroupDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerRemoveManyAssets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerRemoveManyAssets>>,
    { groupId: string; data: RemoveManyAssetsFromAssetGroupDto }
  > = (props) => {
    const { groupId, data } = props ?? {};

    return assetGroupControllerRemoveManyAssets(groupId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerRemoveManyAssetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof assetGroupControllerRemoveManyAssets>>
>;
export type AssetGroupControllerRemoveManyAssetsMutationBody =
  RemoveManyAssetsFromAssetGroupDto;
export type AssetGroupControllerRemoveManyAssetsMutationError = unknown;

/**
 * @summary Remove multiple assets from asset group
 */
export const useAssetGroupControllerRemoveManyAssets = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerRemoveManyAssets>>,
      TError,
      { groupId: string; data: RemoveManyAssetsFromAssetGroupDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerRemoveManyAssets>>,
  TError,
  { groupId: string; data: RemoveManyAssetsFromAssetGroupDto },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerRemoveManyAssetsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves assets associated with a specific asset group with pagination.
 * @summary Get assets by asset group ID
 */
export const assetGroupControllerGetAssetsByAssetGroupsId = (
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyAssetDto>(
    {
      url: `/api/asset-group/${assetGroupId}/assets`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerGetAssetsByAssetGroupsIdInfiniteQueryKey = (
  assetGroupId?: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
) => {
  return [
    'infinite',
    `/api/asset-group/${assetGroupId}/assets`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetGroupControllerGetAssetsByAssetGroupsIdQueryKey = (
  assetGroupId?: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
) => {
  return [
    `/api/asset-group/${assetGroupId}/assets`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetGroupControllerGetAssetsByAssetGroupsIdInfiniteQueryOptions =
  <
    TData = InfiniteData<
      Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
      AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
    >,
    TError = unknown,
  >(
    assetGroupId: string,
    params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
    options?: {
      query?: Partial<
        UseInfiniteQueryOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          TError,
          TData,
          QueryKey,
          AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getAssetGroupControllerGetAssetsByAssetGroupsIdInfiniteQueryKey(
        assetGroupId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
      QueryKey,
      AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
    > = ({ signal, pageParam }) =>
      assetGroupControllerGetAssetsByAssetGroupsId(
        assetGroupId,
        { ...params, page: pageParam || params?.['page'] },
        requestOptions,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!assetGroupId,
      ...queryOptions,
    } as UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
      TError,
      TData,
      QueryKey,
      AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type AssetGroupControllerGetAssetsByAssetGroupsIdInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>
  >;
export type AssetGroupControllerGetAssetsByAssetGroupsIdInfiniteQueryError =
  unknown;

export function useAssetGroupControllerGetAssetsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
    AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
    AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
    AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets by asset group ID
 */

export function useAssetGroupControllerGetAssetsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
    AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsByAssetGroupsIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetAssetsByAssetGroupsIdInfiniteQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetGroupControllerGetAssetsByAssetGroupsIdQueryOptions = <
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetGroupControllerGetAssetsByAssetGroupsIdQueryKey(
      assetGroupId,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>
  > = ({ signal }) =>
    assetGroupControllerGetAssetsByAssetGroupsId(
      assetGroupId,
      params,
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!assetGroupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetAssetsByAssetGroupsIdQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>>
  >;
export type AssetGroupControllerGetAssetsByAssetGroupsIdQueryError = unknown;

export function useAssetGroupControllerGetAssetsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets by asset group ID
 */

export function useAssetGroupControllerGetAssetsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsByAssetGroupsId>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetAssetsByAssetGroupsIdQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves workflows associated with a specific asset group with pagination.
 * @summary Get workflows by asset group ID
 */
export const assetGroupControllerGetWorkflowsByAssetGroupsId = (
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyAssetGroupWorkflowDto>(
    {
      url: `/api/asset-group/${assetGroupId}/workflows`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerGetWorkflowsByAssetGroupsIdInfiniteQueryKey =
  (
    assetGroupId?: string,
    params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  ) => {
    return [
      'infinite',
      `/api/asset-group/${assetGroupId}/workflows`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getAssetGroupControllerGetWorkflowsByAssetGroupsIdQueryKey = (
  assetGroupId?: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
) => {
  return [
    `/api/asset-group/${assetGroupId}/workflows`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetGroupControllerGetWorkflowsByAssetGroupsIdInfiniteQueryOptions =
  <
    TData = InfiniteData<
      Awaited<
        ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
      >,
      AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
    >,
    TError = unknown,
  >(
    assetGroupId: string,
    params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
    options?: {
      query?: Partial<
        UseInfiniteQueryOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          TError,
          TData,
          QueryKey,
          AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getAssetGroupControllerGetWorkflowsByAssetGroupsIdInfiniteQueryKey(
        assetGroupId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
      >,
      QueryKey,
      AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
    > = ({ signal, pageParam }) =>
      assetGroupControllerGetWorkflowsByAssetGroupsId(
        assetGroupId,
        { ...params, page: pageParam || params?.['page'] },
        requestOptions,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!assetGroupId,
      ...queryOptions,
    } as UseInfiniteQueryOptions<
      Awaited<
        ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
      >,
      TError,
      TData,
      QueryKey,
      AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type AssetGroupControllerGetWorkflowsByAssetGroupsIdInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>
  >;
export type AssetGroupControllerGetWorkflowsByAssetGroupsIdInfiniteQueryError =
  unknown;

export function useAssetGroupControllerGetWorkflowsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>,
    AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>,
    AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>,
    AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workflows by asset group ID
 */

export function useAssetGroupControllerGetWorkflowsByAssetGroupsIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>,
    AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsByAssetGroupsIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetWorkflowsByAssetGroupsIdInfiniteQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetGroupControllerGetWorkflowsByAssetGroupsIdQueryOptions = <
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetGroupControllerGetWorkflowsByAssetGroupsIdQueryKey(
      assetGroupId,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>
  > = ({ signal }) =>
    assetGroupControllerGetWorkflowsByAssetGroupsId(
      assetGroupId,
      params,
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!assetGroupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetWorkflowsByAssetGroupsIdQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>>
  >;
export type AssetGroupControllerGetWorkflowsByAssetGroupsIdQueryError = unknown;

export function useAssetGroupControllerGetWorkflowsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workflows by asset group ID
 */

export function useAssetGroupControllerGetWorkflowsByAssetGroupsId<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsByAssetGroupsIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsByAssetGroupsId>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetWorkflowsByAssetGroupsIdQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves assets not associated with a specific asset group with pagination.
 * @summary Get assets not in asset group
 */
export const assetGroupControllerGetAssetsNotInAssetGroup = (
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyAssetDto>(
    {
      url: `/api/asset-group/${assetGroupId}/assets/not-in-group`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerGetAssetsNotInAssetGroupInfiniteQueryKey = (
  assetGroupId?: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
) => {
  return [
    'infinite',
    `/api/asset-group/${assetGroupId}/assets/not-in-group`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetGroupControllerGetAssetsNotInAssetGroupQueryKey = (
  assetGroupId?: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
) => {
  return [
    `/api/asset-group/${assetGroupId}/assets/not-in-group`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetGroupControllerGetAssetsNotInAssetGroupInfiniteQueryOptions =
  <
    TData = InfiniteData<
      Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
      AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
    >,
    TError = unknown,
  >(
    assetGroupId: string,
    params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
    options?: {
      query?: Partial<
        UseInfiniteQueryOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          TError,
          TData,
          QueryKey,
          AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getAssetGroupControllerGetAssetsNotInAssetGroupInfiniteQueryKey(
        assetGroupId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
      QueryKey,
      AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
    > = ({ signal, pageParam }) =>
      assetGroupControllerGetAssetsNotInAssetGroup(
        assetGroupId,
        { ...params, page: pageParam || params?.['page'] },
        requestOptions,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!assetGroupId,
      ...queryOptions,
    } as UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
      TError,
      TData,
      QueryKey,
      AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type AssetGroupControllerGetAssetsNotInAssetGroupInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>
  >;
export type AssetGroupControllerGetAssetsNotInAssetGroupInfiniteQueryError =
  unknown;

export function useAssetGroupControllerGetAssetsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
    AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
    AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
    AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets not in asset group
 */

export function useAssetGroupControllerGetAssetsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
    AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetAssetsNotInAssetGroupParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetAssetsNotInAssetGroupInfiniteQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetGroupControllerGetAssetsNotInAssetGroupQueryOptions = <
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetGroupControllerGetAssetsNotInAssetGroupQueryKey(
      assetGroupId,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>
  > = ({ signal }) =>
    assetGroupControllerGetAssetsNotInAssetGroup(
      assetGroupId,
      params,
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!assetGroupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetAssetsNotInAssetGroupQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>>
  >;
export type AssetGroupControllerGetAssetsNotInAssetGroupQueryError = unknown;

export function useAssetGroupControllerGetAssetsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetAssetsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get assets not in asset group
 */

export function useAssetGroupControllerGetAssetsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetAssetsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetAssetsNotInAssetGroup>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetAssetsNotInAssetGroupQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves workflows not associated with a specific asset group but preinstalled in the workspace with pagination.
 * @summary Get workflows not in asset group (preinstalled in workspace)
 */
export const assetGroupControllerGetWorkflowsNotInAssetGroup = (
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyWorkflowDto>(
    {
      url: `/api/asset-group/${assetGroupId}/workflows/not-in-group`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getAssetGroupControllerGetWorkflowsNotInAssetGroupInfiniteQueryKey =
  (
    assetGroupId?: string,
    params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  ) => {
    return [
      'infinite',
      `/api/asset-group/${assetGroupId}/workflows/not-in-group`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getAssetGroupControllerGetWorkflowsNotInAssetGroupQueryKey = (
  assetGroupId?: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
) => {
  return [
    `/api/asset-group/${assetGroupId}/workflows/not-in-group`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAssetGroupControllerGetWorkflowsNotInAssetGroupInfiniteQueryOptions =
  <
    TData = InfiniteData<
      Awaited<
        ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
      >,
      AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
    >,
    TError = unknown,
  >(
    assetGroupId: string,
    params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
    options?: {
      query?: Partial<
        UseInfiniteQueryOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          TError,
          TData,
          QueryKey,
          AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
        >
      >;
      request?: SecondParameter<typeof orvalClient>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getAssetGroupControllerGetWorkflowsNotInAssetGroupInfiniteQueryKey(
        assetGroupId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
      >,
      QueryKey,
      AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
    > = ({ signal, pageParam }) =>
      assetGroupControllerGetWorkflowsNotInAssetGroup(
        assetGroupId,
        { ...params, page: pageParam || params?.['page'] },
        requestOptions,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!assetGroupId,
      ...queryOptions,
    } as UseInfiniteQueryOptions<
      Awaited<
        ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
      >,
      TError,
      TData,
      QueryKey,
      AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type AssetGroupControllerGetWorkflowsNotInAssetGroupInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>
  >;
export type AssetGroupControllerGetWorkflowsNotInAssetGroupInfiniteQueryError =
  unknown;

export function useAssetGroupControllerGetWorkflowsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>,
    AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>,
    AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>,
    AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workflows not in asset group (preinstalled in workspace)
 */

export function useAssetGroupControllerGetWorkflowsNotInAssetGroupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>,
    AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData,
        QueryKey,
        AssetGroupControllerGetWorkflowsNotInAssetGroupParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetWorkflowsNotInAssetGroupInfiniteQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAssetGroupControllerGetWorkflowsNotInAssetGroupQueryOptions = <
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetGroupControllerGetWorkflowsNotInAssetGroupQueryKey(
      assetGroupId,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>
  > = ({ signal }) =>
    assetGroupControllerGetWorkflowsNotInAssetGroup(
      assetGroupId,
      params,
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!assetGroupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AssetGroupControllerGetWorkflowsNotInAssetGroupQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>>
  >;
export type AssetGroupControllerGetWorkflowsNotInAssetGroupQueryError = unknown;

export function useAssetGroupControllerGetWorkflowsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params: undefined | AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >,
          TError,
          Awaited<
            ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAssetGroupControllerGetWorkflowsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get workflows not in asset group (preinstalled in workspace)
 */

export function useAssetGroupControllerGetWorkflowsNotInAssetGroup<
  TData = Awaited<
    ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
  >,
  TError = unknown,
>(
  assetGroupId: string,
  params?: AssetGroupControllerGetWorkflowsNotInAssetGroupParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof assetGroupControllerGetWorkflowsNotInAssetGroup>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAssetGroupControllerGetWorkflowsNotInAssetGroupQueryOptions(
      assetGroupId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates the relationship between an asset group and workflow, primarily to change the schedule.
 * @summary Update asset group workflow relationship
 */
export const assetGroupControllerUpdateAssetGroupWorkflow = (
  id: string,
  updateAssetGroupWorkflowDto: UpdateAssetGroupWorkflowDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AssetGroupWorkflow>(
    {
      url: `/api/asset-group/workflows/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateAssetGroupWorkflowDto,
    },
    options,
  );
};

export const getAssetGroupControllerUpdateAssetGroupWorkflowMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupWorkflow>>,
    TError,
    { id: string; data: UpdateAssetGroupWorkflowDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupWorkflow>>,
  TError,
  { id: string; data: UpdateAssetGroupWorkflowDto },
  TContext
> => {
  const mutationKey = ['assetGroupControllerUpdateAssetGroupWorkflow'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupWorkflow>>,
    { id: string; data: UpdateAssetGroupWorkflowDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return assetGroupControllerUpdateAssetGroupWorkflow(
      id,
      data,
      requestOptions,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerUpdateAssetGroupWorkflowMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupWorkflow>>
  >;
export type AssetGroupControllerUpdateAssetGroupWorkflowMutationBody =
  UpdateAssetGroupWorkflowDto;
export type AssetGroupControllerUpdateAssetGroupWorkflowMutationError = unknown;

/**
 * @summary Update asset group workflow relationship
 */
export const useAssetGroupControllerUpdateAssetGroupWorkflow = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupWorkflow>>,
      TError,
      { id: string; data: UpdateAssetGroupWorkflowDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerUpdateAssetGroupWorkflow>>,
  TError,
  { id: string; data: UpdateAssetGroupWorkflowDto },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerUpdateAssetGroupWorkflowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Runs the scheduler for a specific asset group workflow.
 * @summary Runs the scheduler for a specific asset group workflow.
 */
export const assetGroupControllerRunGroupWorkflowScheduler = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/asset-group/workflows/${id}/run`, method: 'POST', signal },
    options,
  );
};

export const getAssetGroupControllerRunGroupWorkflowSchedulerMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assetGroupControllerRunGroupWorkflowScheduler>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assetGroupControllerRunGroupWorkflowScheduler>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['assetGroupControllerRunGroupWorkflowScheduler'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assetGroupControllerRunGroupWorkflowScheduler>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return assetGroupControllerRunGroupWorkflowScheduler(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssetGroupControllerRunGroupWorkflowSchedulerMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof assetGroupControllerRunGroupWorkflowScheduler>>
  >;

export type AssetGroupControllerRunGroupWorkflowSchedulerMutationError =
  unknown;

/**
 * @summary Runs the scheduler for a specific asset group workflow.
 */
export const useAssetGroupControllerRunGroupWorkflowScheduler = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assetGroupControllerRunGroupWorkflowScheduler>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assetGroupControllerRunGroupWorkflowScheduler>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getAssetGroupControllerRunGroupWorkflowSchedulerMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a list of all issues with pagination and filtering.
 * @summary Get all issues
 */
export const issuesControllerGetMany = (
  params?: IssuesControllerGetManyParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyIssueDto>(
    { url: `/api/issues`, method: 'GET', params, signal },
    options,
  );
};

export const getIssuesControllerGetManyInfiniteQueryKey = (
  params?: IssuesControllerGetManyParams,
) => {
  return ['infinite', `/api/issues`, ...(params ? [params] : [])] as const;
};

export const getIssuesControllerGetManyQueryKey = (
  params?: IssuesControllerGetManyParams,
) => {
  return [`/api/issues`, ...(params ? [params] : [])] as const;
};

export const getIssuesControllerGetManyInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    IssuesControllerGetManyParams['page']
  >,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetManyParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getIssuesControllerGetManyInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    QueryKey,
    IssuesControllerGetManyParams['page']
  > = ({ signal, pageParam }) =>
    issuesControllerGetMany(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    TError,
    TData,
    QueryKey,
    IssuesControllerGetManyParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IssuesControllerGetManyInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerGetMany>>
>;
export type IssuesControllerGetManyInfiniteQueryError = unknown;

export function useIssuesControllerGetManyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    IssuesControllerGetManyParams['page']
  >,
  TError = unknown,
>(
  params: undefined | IssuesControllerGetManyParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetManyParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetMany>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetMany>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetManyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    IssuesControllerGetManyParams['page']
  >,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetManyParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetMany>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetMany>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetManyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    IssuesControllerGetManyParams['page']
  >,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetManyParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all issues
 */

export function useIssuesControllerGetManyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    IssuesControllerGetManyParams['page']
  >,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetManyParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getIssuesControllerGetManyInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getIssuesControllerGetManyQueryOptions = <
  TData = Awaited<ReturnType<typeof issuesControllerGetMany>>,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getIssuesControllerGetManyQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof issuesControllerGetMany>>
  > = ({ signal }) => issuesControllerGetMany(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof issuesControllerGetMany>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IssuesControllerGetManyQueryResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerGetMany>>
>;
export type IssuesControllerGetManyQueryError = unknown;

export function useIssuesControllerGetMany<
  TData = Awaited<ReturnType<typeof issuesControllerGetMany>>,
  TError = unknown,
>(
  params: undefined | IssuesControllerGetManyParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetMany>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetMany>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetMany<
  TData = Awaited<ReturnType<typeof issuesControllerGetMany>>,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetMany>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetMany>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetMany<
  TData = Awaited<ReturnType<typeof issuesControllerGetMany>>,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all issues
 */

export function useIssuesControllerGetMany<
  TData = Awaited<ReturnType<typeof issuesControllerGetMany>>,
  TError = unknown,
>(
  params?: IssuesControllerGetManyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetMany>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getIssuesControllerGetManyQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new issue linked to a source (e.g. vulnerability).
 * @summary Create issue
 */
export const issuesControllerCreate = (
  createIssueDto: CreateIssueDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Issue>(
    {
      url: `/api/issues`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createIssueDto,
      signal,
    },
    options,
  );
};

export const getIssuesControllerCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof issuesControllerCreate>>,
    TError,
    { data: CreateIssueDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof issuesControllerCreate>>,
  TError,
  { data: CreateIssueDto },
  TContext
> => {
  const mutationKey = ['issuesControllerCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof issuesControllerCreate>>,
    { data: CreateIssueDto }
  > = (props) => {
    const { data } = props ?? {};

    return issuesControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IssuesControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerCreate>>
>;
export type IssuesControllerCreateMutationBody = CreateIssueDto;
export type IssuesControllerCreateMutationError = unknown;

/**
 * @summary Create issue
 */
export const useIssuesControllerCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof issuesControllerCreate>>,
      TError,
      { data: CreateIssueDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof issuesControllerCreate>>,
  TError,
  { data: CreateIssueDto },
  TContext
> => {
  const mutationOptions = getIssuesControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve details of a specific issue.
 * @summary Get issue by ID
 */
export const issuesControllerGetById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Issue>(
    { url: `/api/issues/${id}`, method: 'GET', signal },
    options,
  );
};

export const getIssuesControllerGetByIdQueryKey = (id?: string) => {
  return [`/api/issues/${id}`] as const;
};

export const getIssuesControllerGetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof issuesControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getIssuesControllerGetByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof issuesControllerGetById>>
  > = ({ signal }) => issuesControllerGetById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof issuesControllerGetById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IssuesControllerGetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerGetById>>
>;
export type IssuesControllerGetByIdQueryError = unknown;

export function useIssuesControllerGetById<
  TData = Awaited<ReturnType<typeof issuesControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetById>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetById<
  TData = Awaited<ReturnType<typeof issuesControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetById>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetById<
  TData = Awaited<ReturnType<typeof issuesControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get issue by ID
 */

export function useIssuesControllerGetById<
  TData = Awaited<ReturnType<typeof issuesControllerGetById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getIssuesControllerGetByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update issue title and tags.
 * @summary Update issue
 */
export const issuesControllerUpdate = (
  id: string,
  updateIssueDto: UpdateIssueDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<Issue>(
    {
      url: `/api/issues/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateIssueDto,
    },
    options,
  );
};

export const getIssuesControllerUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof issuesControllerUpdate>>,
    TError,
    { id: string; data: UpdateIssueDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof issuesControllerUpdate>>,
  TError,
  { id: string; data: UpdateIssueDto },
  TContext
> => {
  const mutationKey = ['issuesControllerUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof issuesControllerUpdate>>,
    { id: string; data: UpdateIssueDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return issuesControllerUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IssuesControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerUpdate>>
>;
export type IssuesControllerUpdateMutationBody = UpdateIssueDto;
export type IssuesControllerUpdateMutationError = unknown;

/**
 * @summary Update issue
 */
export const useIssuesControllerUpdate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof issuesControllerUpdate>>,
      TError,
      { id: string; data: UpdateIssueDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof issuesControllerUpdate>>,
  TError,
  { id: string; data: UpdateIssueDto },
  TContext
> => {
  const mutationOptions = getIssuesControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Change the status of an issue.
 * @summary Change issue status
 */
export const issuesControllerChangeStatus = (
  id: string,
  changeIssueStatusDto: ChangeIssueStatusDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<Issue>(
    {
      url: `/api/issues/${id}/status`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: changeIssueStatusDto,
    },
    options,
  );
};

export const getIssuesControllerChangeStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof issuesControllerChangeStatus>>,
    TError,
    { id: string; data: ChangeIssueStatusDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof issuesControllerChangeStatus>>,
  TError,
  { id: string; data: ChangeIssueStatusDto },
  TContext
> => {
  const mutationKey = ['issuesControllerChangeStatus'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof issuesControllerChangeStatus>>,
    { id: string; data: ChangeIssueStatusDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return issuesControllerChangeStatus(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IssuesControllerChangeStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerChangeStatus>>
>;
export type IssuesControllerChangeStatusMutationBody = ChangeIssueStatusDto;
export type IssuesControllerChangeStatusMutationError = unknown;

/**
 * @summary Change issue status
 */
export const useIssuesControllerChangeStatus = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof issuesControllerChangeStatus>>,
      TError,
      { id: string; data: ChangeIssueStatusDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof issuesControllerChangeStatus>>,
  TError,
  { id: string; data: ChangeIssueStatusDto },
  TContext
> => {
  const mutationOptions =
    getIssuesControllerChangeStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new comment for a specific issue.
 * @summary Create comment for issue
 */
export const issuesControllerCreateComment = (
  issueId: string,
  createIssueCommentDto: CreateIssueCommentDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<IssueComment>(
    {
      url: `/api/issues/${issueId}/comments`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createIssueCommentDto,
      signal,
    },
    options,
  );
};

export const getIssuesControllerCreateCommentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof issuesControllerCreateComment>>,
    TError,
    { issueId: string; data: CreateIssueCommentDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof issuesControllerCreateComment>>,
  TError,
  { issueId: string; data: CreateIssueCommentDto },
  TContext
> => {
  const mutationKey = ['issuesControllerCreateComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof issuesControllerCreateComment>>,
    { issueId: string; data: CreateIssueCommentDto }
  > = (props) => {
    const { issueId, data } = props ?? {};

    return issuesControllerCreateComment(issueId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IssuesControllerCreateCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerCreateComment>>
>;
export type IssuesControllerCreateCommentMutationBody = CreateIssueCommentDto;
export type IssuesControllerCreateCommentMutationError = unknown;

/**
 * @summary Create comment for issue
 */
export const useIssuesControllerCreateComment = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof issuesControllerCreateComment>>,
      TError,
      { issueId: string; data: CreateIssueCommentDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof issuesControllerCreateComment>>,
  TError,
  { issueId: string; data: CreateIssueCommentDto },
  TContext
> => {
  const mutationOptions =
    getIssuesControllerCreateCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve paginated comments for a specific issue.
 * @summary Get comments by issue ID
 */
export const issuesControllerGetCommentsByIssueId = (
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyIssueCommentDto>(
    { url: `/api/issues/${issueId}/comments`, method: 'GET', params, signal },
    options,
  );
};

export const getIssuesControllerGetCommentsByIssueIdInfiniteQueryKey = (
  issueId?: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
) => {
  return [
    'infinite',
    `/api/issues/${issueId}/comments`,
    ...(params ? [params] : []),
  ] as const;
};

export const getIssuesControllerGetCommentsByIssueIdQueryKey = (
  issueId?: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
) => {
  return [
    `/api/issues/${issueId}/comments`,
    ...(params ? [params] : []),
  ] as const;
};

export const getIssuesControllerGetCommentsByIssueIdInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    IssuesControllerGetCommentsByIssueIdParams['page']
  >,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetCommentsByIssueIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getIssuesControllerGetCommentsByIssueIdInfiniteQueryKey(issueId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    QueryKey,
    IssuesControllerGetCommentsByIssueIdParams['page']
  > = ({ signal, pageParam }) =>
    issuesControllerGetCommentsByIssueId(
      issueId,
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!issueId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    TError,
    TData,
    QueryKey,
    IssuesControllerGetCommentsByIssueIdParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IssuesControllerGetCommentsByIssueIdInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>>;
export type IssuesControllerGetCommentsByIssueIdInfiniteQueryError = unknown;

export function useIssuesControllerGetCommentsByIssueIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    IssuesControllerGetCommentsByIssueIdParams['page']
  >,
  TError = unknown,
>(
  issueId: string,
  params: undefined | IssuesControllerGetCommentsByIssueIdParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetCommentsByIssueIdParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetCommentsByIssueIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    IssuesControllerGetCommentsByIssueIdParams['page']
  >,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetCommentsByIssueIdParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetCommentsByIssueIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    IssuesControllerGetCommentsByIssueIdParams['page']
  >,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetCommentsByIssueIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comments by issue ID
 */

export function useIssuesControllerGetCommentsByIssueIdInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    IssuesControllerGetCommentsByIssueIdParams['page']
  >,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData,
        QueryKey,
        IssuesControllerGetCommentsByIssueIdParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getIssuesControllerGetCommentsByIssueIdInfiniteQueryOptions(
      issueId,
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getIssuesControllerGetCommentsByIssueIdQueryOptions = <
  TData = Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getIssuesControllerGetCommentsByIssueIdQueryKey(issueId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>
  > = ({ signal }) =>
    issuesControllerGetCommentsByIssueId(
      issueId,
      params,
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!issueId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IssuesControllerGetCommentsByIssueIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>
>;
export type IssuesControllerGetCommentsByIssueIdQueryError = unknown;

export function useIssuesControllerGetCommentsByIssueId<
  TData = Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
  TError = unknown,
>(
  issueId: string,
  params: undefined | IssuesControllerGetCommentsByIssueIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetCommentsByIssueId<
  TData = Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
          TError,
          Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIssuesControllerGetCommentsByIssueId<
  TData = Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comments by issue ID
 */

export function useIssuesControllerGetCommentsByIssueId<
  TData = Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
  TError = unknown,
>(
  issueId: string,
  params?: IssuesControllerGetCommentsByIssueIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof issuesControllerGetCommentsByIssueId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getIssuesControllerGetCommentsByIssueIdQueryOptions(
    issueId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update a comment by its ID. Only the creator of the comment can update it.
 * @summary Update comment by ID
 */
export const issuesControllerUpdateCommentById = (
  id: string,
  updateIssueCommentDto: UpdateIssueCommentDto,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<IssueComment>(
    {
      url: `/api/issues/comments/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateIssueCommentDto,
    },
    options,
  );
};

export const getIssuesControllerUpdateCommentByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof issuesControllerUpdateCommentById>>,
    TError,
    { id: string; data: UpdateIssueCommentDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof issuesControllerUpdateCommentById>>,
  TError,
  { id: string; data: UpdateIssueCommentDto },
  TContext
> => {
  const mutationKey = ['issuesControllerUpdateCommentById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof issuesControllerUpdateCommentById>>,
    { id: string; data: UpdateIssueCommentDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return issuesControllerUpdateCommentById(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IssuesControllerUpdateCommentByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerUpdateCommentById>>
>;
export type IssuesControllerUpdateCommentByIdMutationBody =
  UpdateIssueCommentDto;
export type IssuesControllerUpdateCommentByIdMutationError = unknown;

/**
 * @summary Update comment by ID
 */
export const useIssuesControllerUpdateCommentById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof issuesControllerUpdateCommentById>>,
      TError,
      { id: string; data: UpdateIssueCommentDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof issuesControllerUpdateCommentById>>,
  TError,
  { id: string; data: UpdateIssueCommentDto },
  TContext
> => {
  const mutationOptions =
    getIssuesControllerUpdateCommentByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete a comment by its ID. Only the creator of the comment can delete it.
 * @summary Delete comment by ID
 */
export const issuesControllerDeleteCommentById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<Object>(
    { url: `/api/issues/comments/${id}`, method: 'DELETE' },
    options,
  );
};

export const getIssuesControllerDeleteCommentByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof issuesControllerDeleteCommentById>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof issuesControllerDeleteCommentById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['issuesControllerDeleteCommentById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof issuesControllerDeleteCommentById>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return issuesControllerDeleteCommentById(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IssuesControllerDeleteCommentByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof issuesControllerDeleteCommentById>>
>;

export type IssuesControllerDeleteCommentByIdMutationError = unknown;

/**
 * @summary Delete comment by ID
 */
export const useIssuesControllerDeleteCommentById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof issuesControllerDeleteCommentById>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof issuesControllerDeleteCommentById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getIssuesControllerDeleteCommentByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a paginated list of notifications for the current user
 * @summary Get all notifications
 */
export const notificationsControllerGetNotifications = (
  params?: NotificationsControllerGetNotificationsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyNotificationResponseDtoDto>(
    { url: `/api/notifications`, method: 'GET', params, signal },
    options,
  );
};

export const getNotificationsControllerGetNotificationsInfiniteQueryKey = (
  params?: NotificationsControllerGetNotificationsParams,
) => {
  return [
    'infinite',
    `/api/notifications`,
    ...(params ? [params] : []),
  ] as const;
};

export const getNotificationsControllerGetNotificationsQueryKey = (
  params?: NotificationsControllerGetNotificationsParams,
) => {
  return [`/api/notifications`, ...(params ? [params] : [])] as const;
};

export const getNotificationsControllerGetNotificationsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    NotificationsControllerGetNotificationsParams['page']
  >,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData,
        QueryKey,
        NotificationsControllerGetNotificationsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getNotificationsControllerGetNotificationsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    QueryKey,
    NotificationsControllerGetNotificationsParams['page']
  > = ({ signal, pageParam }) =>
    notificationsControllerGetNotifications(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    TError,
    TData,
    QueryKey,
    NotificationsControllerGetNotificationsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NotificationsControllerGetNotificationsInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>
  >;
export type NotificationsControllerGetNotificationsInfiniteQueryError = unknown;

export function useNotificationsControllerGetNotificationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    NotificationsControllerGetNotificationsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | NotificationsControllerGetNotificationsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData,
        QueryKey,
        NotificationsControllerGetNotificationsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerGetNotificationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    NotificationsControllerGetNotificationsParams['page']
  >,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData,
        QueryKey,
        NotificationsControllerGetNotificationsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerGetNotificationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    NotificationsControllerGetNotificationsParams['page']
  >,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData,
        QueryKey,
        NotificationsControllerGetNotificationsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all notifications
 */

export function useNotificationsControllerGetNotificationsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    NotificationsControllerGetNotificationsParams['page']
  >,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData,
        QueryKey,
        NotificationsControllerGetNotificationsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getNotificationsControllerGetNotificationsInfiniteQueryOptions(
      params,
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getNotificationsControllerGetNotificationsQueryOptions = <
  TData = Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getNotificationsControllerGetNotificationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>
  > = ({ signal }) =>
    notificationsControllerGetNotifications(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NotificationsControllerGetNotificationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof notificationsControllerGetNotifications>>
>;
export type NotificationsControllerGetNotificationsQueryError = unknown;

export function useNotificationsControllerGetNotifications<
  TData = Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
  TError = unknown,
>(
  params: undefined | NotificationsControllerGetNotificationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerGetNotifications<
  TData = Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerGetNotifications>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerGetNotifications<
  TData = Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all notifications
 */

export function useNotificationsControllerGetNotifications<
  TData = Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
  TError = unknown,
>(
  params?: NotificationsControllerGetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetNotifications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNotificationsControllerGetNotificationsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new notification for a specific user or group of users
 * @summary Create a notification
 */
export const notificationsControllerCreateNotification = (
  createNotificationDto: CreateNotificationDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    {
      url: `/api/notifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createNotificationDto,
      signal,
    },
    options,
  );
};

export const getNotificationsControllerCreateNotificationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsControllerCreateNotification>>,
    TError,
    { data: CreateNotificationDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsControllerCreateNotification>>,
  TError,
  { data: CreateNotificationDto },
  TContext
> => {
  const mutationKey = ['notificationsControllerCreateNotification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsControllerCreateNotification>>,
    { data: CreateNotificationDto }
  > = (props) => {
    const { data } = props ?? {};

    return notificationsControllerCreateNotification(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsControllerCreateNotificationMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof notificationsControllerCreateNotification>>
  >;
export type NotificationsControllerCreateNotificationMutationBody =
  CreateNotificationDto;
export type NotificationsControllerCreateNotificationMutationError = unknown;

/**
 * @summary Create a notification
 */
export const useNotificationsControllerCreateNotification = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof notificationsControllerCreateNotification>>,
      TError,
      { data: CreateNotificationDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof notificationsControllerCreateNotification>>,
  TError,
  { data: CreateNotificationDto },
  TContext
> => {
  const mutationOptions =
    getNotificationsControllerCreateNotificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Subscribe to a Server-Sent Events (SSE) stream for real-time notifications
 * @summary Subscribe to notifications stream
 */
export const notificationsControllerStream = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/notifications/stream`, method: 'GET', signal },
    options,
  );
};

export const getNotificationsControllerStreamQueryKey = () => {
  return [`/api/notifications/stream`] as const;
};

export const getNotificationsControllerStreamQueryOptions = <
  TData = Awaited<ReturnType<typeof notificationsControllerStream>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof notificationsControllerStream>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getNotificationsControllerStreamQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notificationsControllerStream>>
  > = ({ signal }) => notificationsControllerStream(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof notificationsControllerStream>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NotificationsControllerStreamQueryResult = NonNullable<
  Awaited<ReturnType<typeof notificationsControllerStream>>
>;
export type NotificationsControllerStreamQueryError = unknown;

export function useNotificationsControllerStream<
  TData = Awaited<ReturnType<typeof notificationsControllerStream>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerStream>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerStream>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerStream>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerStream<
  TData = Awaited<ReturnType<typeof notificationsControllerStream>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerStream>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerStream>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerStream>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerStream<
  TData = Awaited<ReturnType<typeof notificationsControllerStream>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerStream>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Subscribe to notifications stream
 */

export function useNotificationsControllerStream<
  TData = Awaited<ReturnType<typeof notificationsControllerStream>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerStream>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNotificationsControllerStreamQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get the total count of unread notifications for the current user
 * @summary Get unread notifications count
 */
export const notificationsControllerGetUnreadCount = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/notifications/unread-count`, method: 'GET', signal },
    options,
  );
};

export const getNotificationsControllerGetUnreadCountQueryKey = () => {
  return [`/api/notifications/unread-count`] as const;
};

export const getNotificationsControllerGetUnreadCountQueryOptions = <
  TData = Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getNotificationsControllerGetUnreadCountQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>
  > = ({ signal }) =>
    notificationsControllerGetUnreadCount(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NotificationsControllerGetUnreadCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>
>;
export type NotificationsControllerGetUnreadCountQueryError = unknown;

export function useNotificationsControllerGetUnreadCount<
  TData = Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerGetUnreadCount<
  TData = Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNotificationsControllerGetUnreadCount<
  TData = Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get unread notifications count
 */

export function useNotificationsControllerGetUnreadCount<
  TData = Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof notificationsControllerGetUnreadCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getNotificationsControllerGetUnreadCountQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Mark all notifications as read for the current user
 * @summary Mark all notifications as read
 */
export const notificationsControllerMarkAllAsRead = (
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/notifications/mark-read`, method: 'PATCH' },
    options,
  );
};

export const getNotificationsControllerMarkAllAsReadMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsControllerMarkAllAsRead>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsControllerMarkAllAsRead>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['notificationsControllerMarkAllAsRead'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsControllerMarkAllAsRead>>,
    void
  > = () => {
    return notificationsControllerMarkAllAsRead(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsControllerMarkAllAsReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof notificationsControllerMarkAllAsRead>>
>;

export type NotificationsControllerMarkAllAsReadMutationError = unknown;

/**
 * @summary Mark all notifications as read
 */
export const useNotificationsControllerMarkAllAsRead = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof notificationsControllerMarkAllAsRead>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof notificationsControllerMarkAllAsRead>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getNotificationsControllerMarkAllAsReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Mark all notifications as unread for the current user
 * @summary Mark all notifications as unread
 */
export const notificationsControllerMarkAllAsUnread = (
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/notifications/mark-unread`, method: 'PATCH' },
    options,
  );
};

export const getNotificationsControllerMarkAllAsUnreadMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsControllerMarkAllAsUnread>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsControllerMarkAllAsUnread>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['notificationsControllerMarkAllAsUnread'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsControllerMarkAllAsUnread>>,
    void
  > = () => {
    return notificationsControllerMarkAllAsUnread(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsControllerMarkAllAsUnreadMutationResult = NonNullable<
  Awaited<ReturnType<typeof notificationsControllerMarkAllAsUnread>>
>;

export type NotificationsControllerMarkAllAsUnreadMutationError = unknown;

/**
 * @summary Mark all notifications as unread
 */
export const useNotificationsControllerMarkAllAsUnread = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof notificationsControllerMarkAllAsUnread>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof notificationsControllerMarkAllAsUnread>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getNotificationsControllerMarkAllAsUnreadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Mark a single notification as read by its ID
 * @summary Mark a specific notification as read
 */
export const notificationsControllerMarkAsRead = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<AppResponseSerialization>(
    { url: `/api/notifications/${id}/read`, method: 'PATCH' },
    options,
  );
};

export const getNotificationsControllerMarkAsReadMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof notificationsControllerMarkAsRead>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof notificationsControllerMarkAsRead>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['notificationsControllerMarkAsRead'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof notificationsControllerMarkAsRead>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return notificationsControllerMarkAsRead(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NotificationsControllerMarkAsReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof notificationsControllerMarkAsRead>>
>;

export type NotificationsControllerMarkAsReadMutationError = unknown;

/**
 * @summary Mark a specific notification as read
 */
export const useNotificationsControllerMarkAsRead = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof notificationsControllerMarkAsRead>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof notificationsControllerMarkAsRead>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getNotificationsControllerMarkAsReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Upload a file to storage
 */
export const storageControllerUploadFile = (
  storageControllerUploadFileBody: StorageControllerUploadFileBody,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`file`, storageControllerUploadFileBody.file);
  if (storageControllerUploadFileBody.bucket !== undefined) {
    formData.append(`bucket`, storageControllerUploadFileBody.bucket);
  }

  return orvalClient<StorageControllerUploadFile200>(
    {
      url: `/api/storage/upload`,
      method: 'POST',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
      signal,
    },
    options,
  );
};

export const getStorageControllerUploadFileMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof storageControllerUploadFile>>,
    TError,
    { data: StorageControllerUploadFileBody },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof storageControllerUploadFile>>,
  TError,
  { data: StorageControllerUploadFileBody },
  TContext
> => {
  const mutationKey = ['storageControllerUploadFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof storageControllerUploadFile>>,
    { data: StorageControllerUploadFileBody }
  > = (props) => {
    const { data } = props ?? {};

    return storageControllerUploadFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StorageControllerUploadFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof storageControllerUploadFile>>
>;
export type StorageControllerUploadFileMutationBody =
  StorageControllerUploadFileBody;
export type StorageControllerUploadFileMutationError = unknown;

/**
 * @summary Upload a file to storage
 */
export const useStorageControllerUploadFile = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof storageControllerUploadFile>>,
      TError,
      { data: StorageControllerUploadFileBody },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof storageControllerUploadFile>>,
  TError,
  { data: StorageControllerUploadFileBody },
  TContext
> => {
  const mutationOptions =
    getStorageControllerUploadFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get a file from storage (public)
 */
export const storageControllerGetFile = (
  bucket: string,
  path: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Blob>(
    {
      url: `/api/storage/${bucket}/${path}`,
      method: 'GET',
      responseType: 'blob',
      signal,
    },
    options,
  );
};

export const getStorageControllerGetFileQueryKey = (
  bucket?: string,
  path?: string,
) => {
  return [`/api/storage/${bucket}/${path}`] as const;
};

export const getStorageControllerGetFileQueryOptions = <
  TData = Awaited<ReturnType<typeof storageControllerGetFile>>,
  TError = void,
>(
  bucket: string,
  path: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerGetFile>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStorageControllerGetFileQueryKey(bucket, path);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof storageControllerGetFile>>
  > = ({ signal }) =>
    storageControllerGetFile(bucket, path, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(bucket && path),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof storageControllerGetFile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StorageControllerGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof storageControllerGetFile>>
>;
export type StorageControllerGetFileQueryError = void;

export function useStorageControllerGetFile<
  TData = Awaited<ReturnType<typeof storageControllerGetFile>>,
  TError = void,
>(
  bucket: string,
  path: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerGetFile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetFile>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetFile>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStorageControllerGetFile<
  TData = Awaited<ReturnType<typeof storageControllerGetFile>>,
  TError = void,
>(
  bucket: string,
  path: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerGetFile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetFile>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetFile>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStorageControllerGetFile<
  TData = Awaited<ReturnType<typeof storageControllerGetFile>>,
  TError = void,
>(
  bucket: string,
  path: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerGetFile>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a file from storage (public)
 */

export function useStorageControllerGetFile<
  TData = Awaited<ReturnType<typeof storageControllerGetFile>>,
  TError = void,
>(
  bucket: string,
  path: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerGetFile>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStorageControllerGetFileQueryOptions(
    bucket,
    path,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Forward an image from a URL
 */
export const storageControllerForwardImage = (
  params: StorageControllerForwardImageParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<Blob>(
    {
      url: `/api/storage/forward`,
      method: 'GET',
      params,
      responseType: 'blob',
      signal,
    },
    options,
  );
};

export const getStorageControllerForwardImageQueryKey = (
  params?: StorageControllerForwardImageParams,
) => {
  return [`/api/storage/forward`, ...(params ? [params] : [])] as const;
};

export const getStorageControllerForwardImageQueryOptions = <
  TData = Awaited<ReturnType<typeof storageControllerForwardImage>>,
  TError = void,
>(
  params: StorageControllerForwardImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerForwardImage>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStorageControllerForwardImageQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof storageControllerForwardImage>>
  > = ({ signal }) =>
    storageControllerForwardImage(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof storageControllerForwardImage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StorageControllerForwardImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof storageControllerForwardImage>>
>;
export type StorageControllerForwardImageQueryError = void;

export function useStorageControllerForwardImage<
  TData = Awaited<ReturnType<typeof storageControllerForwardImage>>,
  TError = void,
>(
  params: StorageControllerForwardImageParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerForwardImage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerForwardImage>>,
          TError,
          Awaited<ReturnType<typeof storageControllerForwardImage>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStorageControllerForwardImage<
  TData = Awaited<ReturnType<typeof storageControllerForwardImage>>,
  TError = void,
>(
  params: StorageControllerForwardImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerForwardImage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerForwardImage>>,
          TError,
          Awaited<ReturnType<typeof storageControllerForwardImage>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStorageControllerForwardImage<
  TData = Awaited<ReturnType<typeof storageControllerForwardImage>>,
  TError = void,
>(
  params: StorageControllerForwardImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerForwardImage>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Forward an image from a URL
 */

export function useStorageControllerForwardImage<
  TData = Awaited<ReturnType<typeof storageControllerForwardImage>>,
  TError = void,
>(
  params: StorageControllerForwardImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof storageControllerForwardImage>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStorageControllerForwardImageQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a flattened array of all tools from all MCP modules.
 * @summary Get all tools from all registered MCP modules.
 */
export const mcpControllerGetMcpTools = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<McpTool[]>(
    { url: `/api/mcp/tools`, method: 'GET', signal },
    options,
  );
};

export const getMcpControllerGetMcpToolsQueryKey = () => {
  return [`/api/mcp/tools`] as const;
};

export const getMcpControllerGetMcpToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMcpControllerGetMcpToolsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof mcpControllerGetMcpTools>>
  > = ({ signal }) => mcpControllerGetMcpTools(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type McpControllerGetMcpToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof mcpControllerGetMcpTools>>
>;
export type McpControllerGetMcpToolsQueryError = unknown;

export function useMcpControllerGetMcpTools<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpTools<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpTools>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpTools<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all tools from all registered MCP modules.
 */

export function useMcpControllerGetMcpTools<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpTools>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMcpControllerGetMcpToolsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates new MCP permissions based on the provided values.
 * @summary Create MCP permissions for a user.
 */
export const mcpControllerCreateMcpPermission = (
  createMcpPermissionsRequestDto: CreateMcpPermissionsRequestDto,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    {
      url: `/api/mcp/permissions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createMcpPermissionsRequestDto,
      signal,
    },
    options,
  );
};

export const getMcpControllerCreateMcpPermissionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mcpControllerCreateMcpPermission>>,
    TError,
    { data: CreateMcpPermissionsRequestDto },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mcpControllerCreateMcpPermission>>,
  TError,
  { data: CreateMcpPermissionsRequestDto },
  TContext
> => {
  const mutationKey = ['mcpControllerCreateMcpPermission'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mcpControllerCreateMcpPermission>>,
    { data: CreateMcpPermissionsRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return mcpControllerCreateMcpPermission(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type McpControllerCreateMcpPermissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof mcpControllerCreateMcpPermission>>
>;
export type McpControllerCreateMcpPermissionMutationBody =
  CreateMcpPermissionsRequestDto;
export type McpControllerCreateMcpPermissionMutationError = unknown;

/**
 * @summary Create MCP permissions for a user.
 */
export const useMcpControllerCreateMcpPermission = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof mcpControllerCreateMcpPermission>>,
      TError,
      { data: CreateMcpPermissionsRequestDto },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof mcpControllerCreateMcpPermission>>,
  TError,
  { data: CreateMcpPermissionsRequestDto },
  TContext
> => {
  const mutationOptions =
    getMcpControllerCreateMcpPermissionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the MCP permissions associated with the current user.
 * @summary Get MCP permissions for a user.
 */
export const mcpControllerGetMcpPermissions = (
  params?: McpControllerGetMcpPermissionsParams,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetManyMcpPermissionDto>(
    { url: `/api/mcp/permissions`, method: 'GET', params, signal },
    options,
  );
};

export const getMcpControllerGetMcpPermissionsInfiniteQueryKey = (
  params?: McpControllerGetMcpPermissionsParams,
) => {
  return [
    'infinite',
    `/api/mcp/permissions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMcpControllerGetMcpPermissionsQueryKey = (
  params?: McpControllerGetMcpPermissionsParams,
) => {
  return [`/api/mcp/permissions`, ...(params ? [params] : [])] as const;
};

export const getMcpControllerGetMcpPermissionsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    McpControllerGetMcpPermissionsParams['page']
  >,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData,
        QueryKey,
        McpControllerGetMcpPermissionsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMcpControllerGetMcpPermissionsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    QueryKey,
    McpControllerGetMcpPermissionsParams['page']
  > = ({ signal, pageParam }) =>
    mcpControllerGetMcpPermissions(
      { ...params, page: pageParam || params?.['page'] },
      requestOptions,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    TError,
    TData,
    QueryKey,
    McpControllerGetMcpPermissionsParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type McpControllerGetMcpPermissionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>
>;
export type McpControllerGetMcpPermissionsInfiniteQueryError = unknown;

export function useMcpControllerGetMcpPermissionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    McpControllerGetMcpPermissionsParams['page']
  >,
  TError = unknown,
>(
  params: undefined | McpControllerGetMcpPermissionsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData,
        QueryKey,
        McpControllerGetMcpPermissionsParams['page']
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpPermissionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    McpControllerGetMcpPermissionsParams['page']
  >,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData,
        QueryKey,
        McpControllerGetMcpPermissionsParams['page']
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
          QueryKey
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpPermissionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    McpControllerGetMcpPermissionsParams['page']
  >,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData,
        QueryKey,
        McpControllerGetMcpPermissionsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get MCP permissions for a user.
 */

export function useMcpControllerGetMcpPermissionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    McpControllerGetMcpPermissionsParams['page']
  >,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData,
        QueryKey,
        McpControllerGetMcpPermissionsParams['page']
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMcpControllerGetMcpPermissionsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMcpControllerGetMcpPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMcpControllerGetMcpPermissionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>
  > = ({ signal }) =>
    mcpControllerGetMcpPermissions(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type McpControllerGetMcpPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>
>;
export type McpControllerGetMcpPermissionsQueryError = unknown;

export function useMcpControllerGetMcpPermissions<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
  TError = unknown,
>(
  params: undefined | McpControllerGetMcpPermissionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpPermissions<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpPermissions<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get MCP permissions for a user.
 */

export function useMcpControllerGetMcpPermissions<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
  TError = unknown,
>(
  params?: McpControllerGetMcpPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpPermissions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMcpControllerGetMcpPermissionsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the API key associated with the specified MCP permission ID.
 * @summary Get the API key for a specific MCP permission.
 */
export const mcpControllerGetMcpApiKey = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<GetApiKeyResponseDto>(
    { url: `/api/mcp/${id}/api-key`, method: 'GET', signal },
    options,
  );
};

export const getMcpControllerGetMcpApiKeyQueryKey = (id?: string) => {
  return [`/api/mcp/${id}/api-key`] as const;
};

export const getMcpControllerGetMcpApiKeyQueryOptions = <
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMcpControllerGetMcpApiKeyQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>
  > = ({ signal }) => mcpControllerGetMcpApiKey(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type McpControllerGetMcpApiKeyQueryResult = NonNullable<
  Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>
>;
export type McpControllerGetMcpApiKeyQueryError = unknown;

export function useMcpControllerGetMcpApiKey<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpApiKey<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
          TError,
          Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMcpControllerGetMcpApiKey<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the API key for a specific MCP permission.
 */

export function useMcpControllerGetMcpApiKey<
  TData = Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof mcpControllerGetMcpApiKey>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMcpControllerGetMcpApiKeyQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Deletes the MCP permission associated with the current user by ID and also deletes the related API key.
 * @summary Delete MCP permission by ID.
 */
export const mcpControllerDeleteMcpPermissionById = (
  id: string,
  options?: SecondParameter<typeof orvalClient>,
) => {
  return orvalClient<DefaultMessageResponseDto>(
    { url: `/api/mcp/permissions/${id}`, method: 'DELETE' },
    options,
  );
};

export const getMcpControllerDeleteMcpPermissionByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mcpControllerDeleteMcpPermissionById>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mcpControllerDeleteMcpPermissionById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['mcpControllerDeleteMcpPermissionById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mcpControllerDeleteMcpPermissionById>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return mcpControllerDeleteMcpPermissionById(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type McpControllerDeleteMcpPermissionByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof mcpControllerDeleteMcpPermissionById>>
>;

export type McpControllerDeleteMcpPermissionByIdMutationError = unknown;

/**
 * @summary Delete MCP permission by ID.
 */
export const useMcpControllerDeleteMcpPermissionById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof mcpControllerDeleteMcpPermissionById>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof mcpControllerDeleteMcpPermissionById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getMcpControllerDeleteMcpPermissionByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const sseControllerSse = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<void>({ url: `/api/mcp`, method: 'GET', signal }, options);
};

export const getSseControllerSseQueryKey = () => {
  return [`/api/mcp`] as const;
};

export const getSseControllerSseQueryOptions = <
  TData = Awaited<ReturnType<typeof sseControllerSse>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof sseControllerSse>>, TError, TData>
  >;
  request?: SecondParameter<typeof orvalClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSseControllerSseQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof sseControllerSse>>
  > = ({ signal }) => sseControllerSse(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sseControllerSse>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SseControllerSseQueryResult = NonNullable<
  Awaited<ReturnType<typeof sseControllerSse>>
>;
export type SseControllerSseQueryError = unknown;

export function useSseControllerSse<
  TData = Awaited<ReturnType<typeof sseControllerSse>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sseControllerSse>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseControllerSse>>,
          TError,
          Awaited<ReturnType<typeof sseControllerSse>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSseControllerSse<
  TData = Awaited<ReturnType<typeof sseControllerSse>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sseControllerSse>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseControllerSse>>,
          TError,
          Awaited<ReturnType<typeof sseControllerSse>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSseControllerSse<
  TData = Awaited<ReturnType<typeof sseControllerSse>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sseControllerSse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSseControllerSse<
  TData = Awaited<ReturnType<typeof sseControllerSse>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sseControllerSse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSseControllerSseQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const sseControllerMessages = (
  options?: SecondParameter<typeof orvalClient>,
  signal?: AbortSignal,
) => {
  return orvalClient<void>(
    { url: `/api/messages`, method: 'POST', signal },
    options,
  );
};

export const getSseControllerMessagesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sseControllerMessages>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof orvalClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sseControllerMessages>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['sseControllerMessages'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sseControllerMessages>>,
    void
  > = () => {
    return sseControllerMessages(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SseControllerMessagesMutationResult = NonNullable<
  Awaited<ReturnType<typeof sseControllerMessages>>
>;

export type SseControllerMessagesMutationError = unknown;

export const useSseControllerMessages = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sseControllerMessages>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof orvalClient>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sseControllerMessages>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSseControllerMessagesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
