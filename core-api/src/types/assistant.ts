// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.4
// source: assistant.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleServerStreamingCall, handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { wrappers } from "protobufjs";
import { Observable } from "rxjs";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "app";

export enum IssueType {
  ISSUE_TYPE_UNSPECIFIED = 0,
  ISSUE_TYPE_SSL = 1,
  ISSUE_TYPE_VULNERABILITY = 2,
  UNRECOGNIZED = -1,
}

export enum AgentType {
  ORCHESTRATION = 0,
  NUCLEI_GENERATOR = 1,
  ANALYSIS = 2,
  UNRECOGNIZED = -1,
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  message: string;
}

export interface LLMConfig {
  provider: string;
  /** Masked when returned in GetLLMConfigs */
  apiKey: string;
  /** Optional: default model for this provider */
  model: string;
  id: string;
  /** Only one config can be preferred per user/workspace */
  isPreferred: boolean;
  /** Whether the config can be edited/deleted (false for system defaults) */
  isEditable: boolean;
  apiUrl: string;
}

export interface GetLLMConfigsRequest {
  search: string;
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface GetLLMConfigsResponse {
  configs: LLMConfig[];
  totalCount: number;
}

export interface UpdateLLMConfigRequest {
  provider: string;
  apiKey: string;
  model: string;
  id: string;
  apiUrl: string;
}

export interface UpdateLLMConfigResponse {
  config: LLMConfig | undefined;
  success: boolean;
}

export interface DeleteLLMConfigRequest {
  id: string;
}

export interface DeleteLLMConfigResponse {
  success: boolean;
}

export interface SetPreferredLLMConfigRequest {
  id: string;
}

export interface SetPreferredLLMConfigResponse {
  config: LLMConfig | undefined;
  success: boolean;
}

export interface ModelInfo {
  id: string;
  /** Human readable name */
  name: string;
  /** "openai", "anthropic", "internal", etc. */
  provider: string;
  description: string;
  /** True if key is valid/present */
  isActive: boolean;
  /** Recommended model */
  isRecommended: boolean;
}

export interface GetAvailableModelsRequest {
}

export interface GetAvailableModelsResponse {
  models: ModelInfo[];
}

export interface DomainClassifyRequest {
  domain: string;
}

export interface DomainClassifyResponse {
  labels: string[];
}

export interface ResolveIssueRequest {
  question: string;
  issueType: IssueType;
  metadata: { [key: string]: any } | undefined;
}

export interface ResolveIssueResponse {
  message: string;
}

export interface Conversation {
  conversationId: string;
  title: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface GetConversationsRequest {
  search: string;
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface GetConversationsResponse {
  conversations: Conversation[];
  totalCount: number;
}

export interface UpdateConversationRequest {
  conversationId: string;
  title: string;
  description: string;
}

export interface UpdateConversationResponse {
  conversation: Conversation | undefined;
}

export interface DeleteConversationRequest {
  conversationId: string;
}

export interface DeleteConversationResponse {
  message: string;
  success: boolean;
}

export interface DeleteConversationsRequest {
}

export interface DeleteConversationsResponse {
  message: string;
  success: boolean;
}

export interface Message {
  messageId: string;
  conversationId: string;
  content: string;
  /** simplified: "text", "thinking", "error", etc. */
  type: string;
  createdAt: string;
  updatedAt: string;
  role: string;
  question: string;
}

export interface GetMessagesRequest {
  conversationId: string;
}

export interface GetMessagesResponse {
  messages: Message[];
}

export interface CreateMessageRequest {
  question: string;
  conversationId: string;
  isCreateConversation: boolean;
  agentType: AgentType;
  model: string;
  provider: string;
  apiKey: string;
}

export interface CreateMessageResponse {
  messageId: string;
  conversationId: string;
  content: string;
  type: string;
  conversation: Conversation | undefined;
  createdAt: string;
}

export interface UpdateMessageRequest {
  conversationId: string;
  messageId: string;
  question: string;
  agentType: AgentType;
}

export interface UpdateMessageResponse {
  messageId: string;
  conversationId: string;
  content: string;
  type: string;
}

export interface DeleteMessageRequest {
  conversationId: string;
  messageId: string;
}

export interface DeleteMessageResponse {
  message: string;
  success: boolean;
}

export interface MCPServer {
  /** Server config (url/command, args, env, headers, disabled, etc.) */
  config: { [key: string]: any } | undefined;
  status?:
    | //
    /** true if server is connected and operational */
    { $case: "active"; active: boolean }
    | //
    /** error message if connection failed or server disabled */
    { $case: "error"; error: string }
    | undefined;
}

/** Get all servers for workspace/user */
export interface GetMCPServersRequest {
}

export interface GetMCPServersResponse {
  servers: MCPServer[];
  /** JSON string of config with status embedded in each server */
  mcpConfigJson: string;
}

/** Add servers - fails if exists */
export interface AddMCPServersRequest {
  mcpConfig: { [key: string]: any } | undefined;
}

export interface AddMCPServersResponse {
  servers: MCPServer[];
  success: boolean;
  error: string;
  /** JSON string of config with metadata and status */
  mcpConfigJson: string;
}

/** Update/Upsert servers - creates if not exists, updates if exists */
export interface UpdateMCPServersRequest {
  /** Claude Desktop format: {"mcpServers": {"name": {...}}} */
  mcpConfig: { [key: string]: any } | undefined;
}

export interface UpdateMCPServersResponse {
  servers: MCPServer[];
  success: boolean;
  /** JSON string of config with metadata and status */
  mcpConfigJson: string;
}

/** Delete MCP servers by config ID */
export interface DeleteMCPServersRequest {
  /** MCP Config ID (UUID) */
  id: string;
}

export interface DeleteMCPServersResponse {
  success: boolean;
  message: string;
}

/** Health check for a specific MCP server */
export interface GetMCPServerHealthRequest {
  /** Name of the server to check */
  serverName: string;
}

export interface GetMCPServerHealthResponse {
  /** true if server is connected and operational */
  isActive: boolean;
  /** "active", "disabled", or "error" */
  status: string;
  /** error message if status is "error" */
  error: string;
}

export const APP_PACKAGE_NAME = "app";

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { message: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLLMConfig(): LLMConfig {
  return { provider: "", apiKey: "", model: "", id: "", isPreferred: false, isEditable: false, apiUrl: "" };
}

export const LLMConfig: MessageFns<LLMConfig> = {
  encode(message: LLMConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.apiKey !== "") {
      writer.uint32(18).string(message.apiKey);
    }
    if (message.model !== "") {
      writer.uint32(26).string(message.model);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.isPreferred !== false) {
      writer.uint32(40).bool(message.isPreferred);
    }
    if (message.isEditable !== false) {
      writer.uint32(48).bool(message.isEditable);
    }
    if (message.apiUrl !== "") {
      writer.uint32(58).string(message.apiUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LLMConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isPreferred = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isEditable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.apiUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetLLMConfigsRequest(): GetLLMConfigsRequest {
  return { search: "", page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const GetLLMConfigsRequest: MessageFns<GetLLMConfigsRequest> = {
  encode(message: GetLLMConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(34).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(42).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLLMConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLLMConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetLLMConfigsResponse(): GetLLMConfigsResponse {
  return { configs: [], totalCount: 0 };
}

export const GetLLMConfigsResponse: MessageFns<GetLLMConfigsResponse> = {
  encode(message: GetLLMConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      LLMConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLLMConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLLMConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(LLMConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateLLMConfigRequest(): UpdateLLMConfigRequest {
  return { provider: "", apiKey: "", model: "", id: "", apiUrl: "" };
}

export const UpdateLLMConfigRequest: MessageFns<UpdateLLMConfigRequest> = {
  encode(message: UpdateLLMConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.apiKey !== "") {
      writer.uint32(18).string(message.apiKey);
    }
    if (message.model !== "") {
      writer.uint32(26).string(message.model);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.apiUrl !== "") {
      writer.uint32(42).string(message.apiUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLLMConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLLMConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.apiUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateLLMConfigResponse(): UpdateLLMConfigResponse {
  return { config: undefined, success: false };
}

export const UpdateLLMConfigResponse: MessageFns<UpdateLLMConfigResponse> = {
  encode(message: UpdateLLMConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      LLMConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLLMConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLLMConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = LLMConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteLLMConfigRequest(): DeleteLLMConfigRequest {
  return { id: "" };
}

export const DeleteLLMConfigRequest: MessageFns<DeleteLLMConfigRequest> = {
  encode(message: DeleteLLMConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLLMConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLLMConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteLLMConfigResponse(): DeleteLLMConfigResponse {
  return { success: false };
}

export const DeleteLLMConfigResponse: MessageFns<DeleteLLMConfigResponse> = {
  encode(message: DeleteLLMConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLLMConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLLMConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSetPreferredLLMConfigRequest(): SetPreferredLLMConfigRequest {
  return { id: "" };
}

export const SetPreferredLLMConfigRequest: MessageFns<SetPreferredLLMConfigRequest> = {
  encode(message: SetPreferredLLMConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetPreferredLLMConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetPreferredLLMConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSetPreferredLLMConfigResponse(): SetPreferredLLMConfigResponse {
  return { config: undefined, success: false };
}

export const SetPreferredLLMConfigResponse: MessageFns<SetPreferredLLMConfigResponse> = {
  encode(message: SetPreferredLLMConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      LLMConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetPreferredLLMConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetPreferredLLMConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = LLMConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseModelInfo(): ModelInfo {
  return { id: "", name: "", provider: "", description: "", isActive: false, isRecommended: false };
}

export const ModelInfo: MessageFns<ModelInfo> = {
  encode(message: ModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.provider !== "") {
      writer.uint32(26).string(message.provider);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(40).bool(message.isActive);
    }
    if (message.isRecommended !== false) {
      writer.uint32(48).bool(message.isRecommended);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRecommended = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAvailableModelsRequest(): GetAvailableModelsRequest {
  return {};
}

export const GetAvailableModelsRequest: MessageFns<GetAvailableModelsRequest> = {
  encode(_: GetAvailableModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAvailableModelsResponse(): GetAvailableModelsResponse {
  return { models: [] };
}

export const GetAvailableModelsResponse: MessageFns<GetAvailableModelsResponse> = {
  encode(message: GetAvailableModelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      ModelInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableModelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.models.push(ModelInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDomainClassifyRequest(): DomainClassifyRequest {
  return { domain: "" };
}

export const DomainClassifyRequest: MessageFns<DomainClassifyRequest> = {
  encode(message: DomainClassifyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainClassifyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainClassifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDomainClassifyResponse(): DomainClassifyResponse {
  return { labels: [] };
}

export const DomainClassifyResponse: MessageFns<DomainClassifyResponse> = {
  encode(message: DomainClassifyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.labels) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainClassifyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainClassifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolveIssueRequest(): ResolveIssueRequest {
  return { question: "", issueType: 0, metadata: undefined };
}

export const ResolveIssueRequest: MessageFns<ResolveIssueRequest> = {
  encode(message: ResolveIssueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(10).string(message.question);
    }
    if (message.issueType !== 0) {
      writer.uint32(16).int32(message.issueType);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveIssueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveIssueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.issueType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolveIssueResponse(): ResolveIssueResponse {
  return { message: "" };
}

export const ResolveIssueResponse: MessageFns<ResolveIssueResponse> = {
  encode(message: ResolveIssueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveIssueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveIssueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConversation(): Conversation {
  return { conversationId: "", title: "", description: "", createdAt: "", updatedAt: "" };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetConversationsRequest(): GetConversationsRequest {
  return { search: "", page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const GetConversationsRequest: MessageFns<GetConversationsRequest> = {
  encode(message: GetConversationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(34).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(42).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetConversationsResponse(): GetConversationsResponse {
  return { conversations: [], totalCount: 0 };
}

export const GetConversationsResponse: MessageFns<GetConversationsResponse> = {
  encode(message: GetConversationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateConversationRequest(): UpdateConversationRequest {
  return { conversationId: "", title: "", description: "" };
}

export const UpdateConversationRequest: MessageFns<UpdateConversationRequest> = {
  encode(message: UpdateConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateConversationResponse(): UpdateConversationResponse {
  return { conversation: undefined };
}

export const UpdateConversationResponse: MessageFns<UpdateConversationResponse> = {
  encode(message: UpdateConversationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConversationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteConversationRequest(): DeleteConversationRequest {
  return { conversationId: "" };
}

export const DeleteConversationRequest: MessageFns<DeleteConversationRequest> = {
  encode(message: DeleteConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteConversationResponse(): DeleteConversationResponse {
  return { message: "", success: false };
}

export const DeleteConversationResponse: MessageFns<DeleteConversationResponse> = {
  encode(message: DeleteConversationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteConversationsRequest(): DeleteConversationsRequest {
  return {};
}

export const DeleteConversationsRequest: MessageFns<DeleteConversationsRequest> = {
  encode(_: DeleteConversationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteConversationsResponse(): DeleteConversationsResponse {
  return { message: "", success: false };
}

export const DeleteConversationsResponse: MessageFns<DeleteConversationsResponse> = {
  encode(message: DeleteConversationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    messageId: "",
    conversationId: "",
    content: "",
    type: "",
    createdAt: "",
    updatedAt: "",
    role: "",
    question: "",
  };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.conversationId !== "") {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    if (message.role !== "") {
      writer.uint32(58).string(message.role);
    }
    if (message.question !== "") {
      writer.uint32(66).string(message.question);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.question = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMessagesRequest(): GetMessagesRequest {
  return { conversationId: "" };
}

export const GetMessagesRequest: MessageFns<GetMessagesRequest> = {
  encode(message: GetMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMessagesResponse(): GetMessagesResponse {
  return { messages: [] };
}

export const GetMessagesResponse: MessageFns<GetMessagesResponse> = {
  encode(message: GetMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateMessageRequest(): CreateMessageRequest {
  return {
    question: "",
    conversationId: "",
    isCreateConversation: false,
    agentType: 0,
    model: "",
    provider: "",
    apiKey: "",
  };
}

export const CreateMessageRequest: MessageFns<CreateMessageRequest> = {
  encode(message: CreateMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(10).string(message.question);
    }
    if (message.conversationId !== "") {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.isCreateConversation !== false) {
      writer.uint32(24).bool(message.isCreateConversation);
    }
    if (message.agentType !== 0) {
      writer.uint32(32).int32(message.agentType);
    }
    if (message.model !== "") {
      writer.uint32(42).string(message.model);
    }
    if (message.provider !== "") {
      writer.uint32(50).string(message.provider);
    }
    if (message.apiKey !== "") {
      writer.uint32(58).string(message.apiKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isCreateConversation = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.agentType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateMessageResponse(): CreateMessageResponse {
  return { messageId: "", conversationId: "", content: "", type: "", conversation: undefined, createdAt: "" };
}

export const CreateMessageResponse: MessageFns<CreateMessageResponse> = {
  encode(message: CreateMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.conversationId !== "") {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateMessageRequest(): UpdateMessageRequest {
  return { conversationId: "", messageId: "", question: "", agentType: 0 };
}

export const UpdateMessageRequest: MessageFns<UpdateMessageRequest> = {
  encode(message: UpdateMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.question !== "") {
      writer.uint32(26).string(message.question);
    }
    if (message.agentType !== 0) {
      writer.uint32(32).int32(message.agentType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.agentType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateMessageResponse(): UpdateMessageResponse {
  return { messageId: "", conversationId: "", content: "", type: "" };
}

export const UpdateMessageResponse: MessageFns<UpdateMessageResponse> = {
  encode(message: UpdateMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.conversationId !== "") {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteMessageRequest(): DeleteMessageRequest {
  return { conversationId: "", messageId: "" };
}

export const DeleteMessageRequest: MessageFns<DeleteMessageRequest> = {
  encode(message: DeleteMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteMessageResponse(): DeleteMessageResponse {
  return { message: "", success: false };
}

export const DeleteMessageResponse: MessageFns<DeleteMessageResponse> = {
  encode(message: DeleteMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMCPServer(): MCPServer {
  return { config: undefined, status: undefined };
}

export const MCPServer: MessageFns<MCPServer> = {
  encode(message: MCPServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(10).fork()).join();
    }
    switch (message.status?.$case) {
      case "active":
        writer.uint32(16).bool(message.status.active);
        break;
      case "error":
        writer.uint32(26).string(message.status.error);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MCPServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMCPServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = { $case: "active", active: reader.bool() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = { $case: "error", error: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMCPServersRequest(): GetMCPServersRequest {
  return {};
}

export const GetMCPServersRequest: MessageFns<GetMCPServersRequest> = {
  encode(_: GetMCPServersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMCPServersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMCPServersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMCPServersResponse(): GetMCPServersResponse {
  return { servers: [], mcpConfigJson: "" };
}

export const GetMCPServersResponse: MessageFns<GetMCPServersResponse> = {
  encode(message: GetMCPServersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.servers) {
      MCPServer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.mcpConfigJson !== "") {
      writer.uint32(18).string(message.mcpConfigJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMCPServersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMCPServersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.servers.push(MCPServer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcpConfigJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAddMCPServersRequest(): AddMCPServersRequest {
  return { mcpConfig: undefined };
}

export const AddMCPServersRequest: MessageFns<AddMCPServersRequest> = {
  encode(message: AddMCPServersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpConfig !== undefined) {
      Struct.encode(Struct.wrap(message.mcpConfig), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddMCPServersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMCPServersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAddMCPServersResponse(): AddMCPServersResponse {
  return { servers: [], success: false, error: "", mcpConfigJson: "" };
}

export const AddMCPServersResponse: MessageFns<AddMCPServersResponse> = {
  encode(message: AddMCPServersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.servers) {
      MCPServer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.mcpConfigJson !== "") {
      writer.uint32(34).string(message.mcpConfigJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddMCPServersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMCPServersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.servers.push(MCPServer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mcpConfigJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateMCPServersRequest(): UpdateMCPServersRequest {
  return { mcpConfig: undefined };
}

export const UpdateMCPServersRequest: MessageFns<UpdateMCPServersRequest> = {
  encode(message: UpdateMCPServersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpConfig !== undefined) {
      Struct.encode(Struct.wrap(message.mcpConfig), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMCPServersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMCPServersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateMCPServersResponse(): UpdateMCPServersResponse {
  return { servers: [], success: false, mcpConfigJson: "" };
}

export const UpdateMCPServersResponse: MessageFns<UpdateMCPServersResponse> = {
  encode(message: UpdateMCPServersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.servers) {
      MCPServer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.mcpConfigJson !== "") {
      writer.uint32(26).string(message.mcpConfigJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMCPServersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMCPServersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.servers.push(MCPServer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mcpConfigJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteMCPServersRequest(): DeleteMCPServersRequest {
  return { id: "" };
}

export const DeleteMCPServersRequest: MessageFns<DeleteMCPServersRequest> = {
  encode(message: DeleteMCPServersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMCPServersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMCPServersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteMCPServersResponse(): DeleteMCPServersResponse {
  return { success: false, message: "" };
}

export const DeleteMCPServersResponse: MessageFns<DeleteMCPServersResponse> = {
  encode(message: DeleteMCPServersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMCPServersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMCPServersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMCPServerHealthRequest(): GetMCPServerHealthRequest {
  return { serverName: "" };
}

export const GetMCPServerHealthRequest: MessageFns<GetMCPServerHealthRequest> = {
  encode(message: GetMCPServerHealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverName !== "") {
      writer.uint32(10).string(message.serverName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMCPServerHealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMCPServerHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMCPServerHealthResponse(): GetMCPServerHealthResponse {
  return { isActive: false, status: "", error: "" };
}

export const GetMCPServerHealthResponse: MessageFns<GetMCPServerHealthResponse> = {
  encode(message: GetMCPServerHealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMCPServerHealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMCPServerHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

wrappers[".google.protobuf.Struct"] = { fromObject: Struct.wrap, toObject: Struct.unwrap } as any;

/**
 * ----------------
 * Health Check
 * ----------------
 */

export interface HealthCheckClient {
  healthCheck(request: HealthCheckRequest): Observable<HealthCheckResponse>;
}

/**
 * ----------------
 * Health Check
 * ----------------
 */

export interface HealthCheckController {
  healthCheck(
    request: HealthCheckRequest,
  ): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function HealthCheckControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["healthCheck"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("HealthCheck", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("HealthCheck", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const HEALTH_CHECK_SERVICE_NAME = "HealthCheck";

/**
 * ----------------
 * Health Check
 * ----------------
 */
export type HealthCheckService = typeof HealthCheckService;
export const HealthCheckService = {
  healthCheck: {
    path: "/app.HealthCheck/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface HealthCheckServer extends UntypedServiceImplementation {
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

/**
 * ----------------
 * LLM Configuration (BYOK)
 * ----------------
 */

export interface LLMConfigServiceClient {
  getLlmConfigs(request: GetLLMConfigsRequest): Observable<GetLLMConfigsResponse>;

  updateLlmConfig(request: UpdateLLMConfigRequest): Observable<UpdateLLMConfigResponse>;

  deleteLlmConfig(request: DeleteLLMConfigRequest): Observable<DeleteLLMConfigResponse>;

  setPreferredLlmConfig(request: SetPreferredLLMConfigRequest): Observable<SetPreferredLLMConfigResponse>;

  getAvailableModels(request: GetAvailableModelsRequest): Observable<GetAvailableModelsResponse>;
}

/**
 * ----------------
 * LLM Configuration (BYOK)
 * ----------------
 */

export interface LLMConfigServiceController {
  getLlmConfigs(
    request: GetLLMConfigsRequest,
  ): Promise<GetLLMConfigsResponse> | Observable<GetLLMConfigsResponse> | GetLLMConfigsResponse;

  updateLlmConfig(
    request: UpdateLLMConfigRequest,
  ): Promise<UpdateLLMConfigResponse> | Observable<UpdateLLMConfigResponse> | UpdateLLMConfigResponse;

  deleteLlmConfig(
    request: DeleteLLMConfigRequest,
  ): Promise<DeleteLLMConfigResponse> | Observable<DeleteLLMConfigResponse> | DeleteLLMConfigResponse;

  setPreferredLlmConfig(
    request: SetPreferredLLMConfigRequest,
  ): Promise<SetPreferredLLMConfigResponse> | Observable<SetPreferredLLMConfigResponse> | SetPreferredLLMConfigResponse;

  getAvailableModels(
    request: GetAvailableModelsRequest,
  ): Promise<GetAvailableModelsResponse> | Observable<GetAvailableModelsResponse> | GetAvailableModelsResponse;
}

export function LLMConfigServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getLlmConfigs",
      "updateLlmConfig",
      "deleteLlmConfig",
      "setPreferredLlmConfig",
      "getAvailableModels",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("LLMConfigService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("LLMConfigService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const LLM_CONFIG_SERVICE_NAME = "LLMConfigService";

/**
 * ----------------
 * LLM Configuration (BYOK)
 * ----------------
 */
export type LLMConfigServiceService = typeof LLMConfigServiceService;
export const LLMConfigServiceService = {
  getLlmConfigs: {
    path: "/app.LLMConfigService/GetLLMConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLLMConfigsRequest): Buffer => Buffer.from(GetLLMConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLLMConfigsRequest => GetLLMConfigsRequest.decode(value),
    responseSerialize: (value: GetLLMConfigsResponse): Buffer =>
      Buffer.from(GetLLMConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetLLMConfigsResponse => GetLLMConfigsResponse.decode(value),
  },
  updateLlmConfig: {
    path: "/app.LLMConfigService/UpdateLLMConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateLLMConfigRequest): Buffer =>
      Buffer.from(UpdateLLMConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateLLMConfigRequest => UpdateLLMConfigRequest.decode(value),
    responseSerialize: (value: UpdateLLMConfigResponse): Buffer =>
      Buffer.from(UpdateLLMConfigResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateLLMConfigResponse => UpdateLLMConfigResponse.decode(value),
  },
  deleteLlmConfig: {
    path: "/app.LLMConfigService/DeleteLLMConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteLLMConfigRequest): Buffer =>
      Buffer.from(DeleteLLMConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteLLMConfigRequest => DeleteLLMConfigRequest.decode(value),
    responseSerialize: (value: DeleteLLMConfigResponse): Buffer =>
      Buffer.from(DeleteLLMConfigResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteLLMConfigResponse => DeleteLLMConfigResponse.decode(value),
  },
  setPreferredLlmConfig: {
    path: "/app.LLMConfigService/SetPreferredLLMConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetPreferredLLMConfigRequest): Buffer =>
      Buffer.from(SetPreferredLLMConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetPreferredLLMConfigRequest => SetPreferredLLMConfigRequest.decode(value),
    responseSerialize: (value: SetPreferredLLMConfigResponse): Buffer =>
      Buffer.from(SetPreferredLLMConfigResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SetPreferredLLMConfigResponse => SetPreferredLLMConfigResponse.decode(value),
  },
  getAvailableModels: {
    path: "/app.LLMConfigService/GetAvailableModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAvailableModelsRequest): Buffer =>
      Buffer.from(GetAvailableModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAvailableModelsRequest => GetAvailableModelsRequest.decode(value),
    responseSerialize: (value: GetAvailableModelsResponse): Buffer =>
      Buffer.from(GetAvailableModelsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAvailableModelsResponse => GetAvailableModelsResponse.decode(value),
  },
} as const;

export interface LLMConfigServiceServer extends UntypedServiceImplementation {
  getLlmConfigs: handleUnaryCall<GetLLMConfigsRequest, GetLLMConfigsResponse>;
  updateLlmConfig: handleUnaryCall<UpdateLLMConfigRequest, UpdateLLMConfigResponse>;
  deleteLlmConfig: handleUnaryCall<DeleteLLMConfigRequest, DeleteLLMConfigResponse>;
  setPreferredLlmConfig: handleUnaryCall<SetPreferredLLMConfigRequest, SetPreferredLLMConfigResponse>;
  getAvailableModels: handleUnaryCall<GetAvailableModelsRequest, GetAvailableModelsResponse>;
}

/**
 * ----------------
 * Domain Classify
 * ----------------
 */

export interface DomainClassifyClient {
  domainClassify(request: DomainClassifyRequest): Observable<DomainClassifyResponse>;
}

/**
 * ----------------
 * Domain Classify
 * ----------------
 */

export interface DomainClassifyController {
  domainClassify(
    request: DomainClassifyRequest,
  ): Promise<DomainClassifyResponse> | Observable<DomainClassifyResponse> | DomainClassifyResponse;
}

export function DomainClassifyControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["domainClassify"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("DomainClassify", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("DomainClassify", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const DOMAIN_CLASSIFY_SERVICE_NAME = "DomainClassify";

/**
 * ----------------
 * Domain Classify
 * ----------------
 */
export type DomainClassifyService = typeof DomainClassifyService;
export const DomainClassifyService = {
  domainClassify: {
    path: "/app.DomainClassify/DomainClassify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DomainClassifyRequest): Buffer =>
      Buffer.from(DomainClassifyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DomainClassifyRequest => DomainClassifyRequest.decode(value),
    responseSerialize: (value: DomainClassifyResponse): Buffer =>
      Buffer.from(DomainClassifyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DomainClassifyResponse => DomainClassifyResponse.decode(value),
  },
} as const;

export interface DomainClassifyServer extends UntypedServiceImplementation {
  domainClassify: handleUnaryCall<DomainClassifyRequest, DomainClassifyResponse>;
}

/**
 * ----------------
 * Issue bot service
 * ----------------
 */

export interface IssueServiceClient {
  resolveIssueServers(request: ResolveIssueRequest): Observable<ResolveIssueResponse>;
}

/**
 * ----------------
 * Issue bot service
 * ----------------
 */

export interface IssueServiceController {
  resolveIssueServers(
    request: ResolveIssueRequest,
  ): Promise<ResolveIssueResponse> | Observable<ResolveIssueResponse> | ResolveIssueResponse;
}

export function IssueServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["resolveIssueServers"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("IssueService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("IssueService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ISSUE_SERVICE_NAME = "IssueService";

/**
 * ----------------
 * Issue bot service
 * ----------------
 */
export type IssueServiceService = typeof IssueServiceService;
export const IssueServiceService = {
  resolveIssueServers: {
    path: "/app.IssueService/ResolveIssueServers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResolveIssueRequest): Buffer => Buffer.from(ResolveIssueRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResolveIssueRequest => ResolveIssueRequest.decode(value),
    responseSerialize: (value: ResolveIssueResponse): Buffer =>
      Buffer.from(ResolveIssueResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResolveIssueResponse => ResolveIssueResponse.decode(value),
  },
} as const;

export interface IssueServiceServer extends UntypedServiceImplementation {
  resolveIssueServers: handleUnaryCall<ResolveIssueRequest, ResolveIssueResponse>;
}

/**
 * ----------------
 * Conversation
 * ----------------
 */

export interface ConversationServiceClient {
  getConversations(request: GetConversationsRequest): Observable<GetConversationsResponse>;

  updateConversation(request: UpdateConversationRequest): Observable<UpdateConversationResponse>;

  deleteConversation(request: DeleteConversationRequest): Observable<DeleteConversationResponse>;

  deleteConversations(request: DeleteConversationsRequest): Observable<DeleteConversationsResponse>;
}

/**
 * ----------------
 * Conversation
 * ----------------
 */

export interface ConversationServiceController {
  getConversations(
    request: GetConversationsRequest,
  ): Promise<GetConversationsResponse> | Observable<GetConversationsResponse> | GetConversationsResponse;

  updateConversation(
    request: UpdateConversationRequest,
  ): Promise<UpdateConversationResponse> | Observable<UpdateConversationResponse> | UpdateConversationResponse;

  deleteConversation(
    request: DeleteConversationRequest,
  ): Promise<DeleteConversationResponse> | Observable<DeleteConversationResponse> | DeleteConversationResponse;

  deleteConversations(
    request: DeleteConversationsRequest,
  ): Promise<DeleteConversationsResponse> | Observable<DeleteConversationsResponse> | DeleteConversationsResponse;
}

export function ConversationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getConversations",
      "updateConversation",
      "deleteConversation",
      "deleteConversations",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ConversationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ConversationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CONVERSATION_SERVICE_NAME = "ConversationService";

/**
 * ----------------
 * Conversation
 * ----------------
 */
export type ConversationServiceService = typeof ConversationServiceService;
export const ConversationServiceService = {
  getConversations: {
    path: "/app.ConversationService/GetConversations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConversationsRequest): Buffer =>
      Buffer.from(GetConversationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConversationsRequest => GetConversationsRequest.decode(value),
    responseSerialize: (value: GetConversationsResponse): Buffer =>
      Buffer.from(GetConversationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetConversationsResponse => GetConversationsResponse.decode(value),
  },
  updateConversation: {
    path: "/app.ConversationService/UpdateConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateConversationRequest): Buffer =>
      Buffer.from(UpdateConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateConversationRequest => UpdateConversationRequest.decode(value),
    responseSerialize: (value: UpdateConversationResponse): Buffer =>
      Buffer.from(UpdateConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateConversationResponse => UpdateConversationResponse.decode(value),
  },
  deleteConversation: {
    path: "/app.ConversationService/DeleteConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConversationRequest): Buffer =>
      Buffer.from(DeleteConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteConversationRequest => DeleteConversationRequest.decode(value),
    responseSerialize: (value: DeleteConversationResponse): Buffer =>
      Buffer.from(DeleteConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteConversationResponse => DeleteConversationResponse.decode(value),
  },
  deleteConversations: {
    path: "/app.ConversationService/DeleteConversations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConversationsRequest): Buffer =>
      Buffer.from(DeleteConversationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteConversationsRequest => DeleteConversationsRequest.decode(value),
    responseSerialize: (value: DeleteConversationsResponse): Buffer =>
      Buffer.from(DeleteConversationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteConversationsResponse => DeleteConversationsResponse.decode(value),
  },
} as const;

export interface ConversationServiceServer extends UntypedServiceImplementation {
  getConversations: handleUnaryCall<GetConversationsRequest, GetConversationsResponse>;
  updateConversation: handleUnaryCall<UpdateConversationRequest, UpdateConversationResponse>;
  deleteConversation: handleUnaryCall<DeleteConversationRequest, DeleteConversationResponse>;
  deleteConversations: handleUnaryCall<DeleteConversationsRequest, DeleteConversationsResponse>;
}

/**
 * ----------------
 * Message
 * ----------------
 */

export interface MessageServiceClient {
  getMessages(request: GetMessagesRequest): Observable<GetMessagesResponse>;

  createMessage(request: CreateMessageRequest): Observable<CreateMessageResponse>;

  updateMessage(request: UpdateMessageRequest): Observable<UpdateMessageResponse>;

  deleteMessage(request: DeleteMessageRequest): Observable<DeleteMessageResponse>;
}

/**
 * ----------------
 * Message
 * ----------------
 */

export interface MessageServiceController {
  getMessages(
    request: GetMessagesRequest,
  ): Promise<GetMessagesResponse> | Observable<GetMessagesResponse> | GetMessagesResponse;

  createMessage(request: CreateMessageRequest): Observable<CreateMessageResponse>;

  updateMessage(request: UpdateMessageRequest): Observable<UpdateMessageResponse>;

  deleteMessage(
    request: DeleteMessageRequest,
  ): Promise<DeleteMessageResponse> | Observable<DeleteMessageResponse> | DeleteMessageResponse;
}

export function MessageServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getMessages", "createMessage", "updateMessage", "deleteMessage"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("MessageService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("MessageService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const MESSAGE_SERVICE_NAME = "MessageService";

/**
 * ----------------
 * Message
 * ----------------
 */
export type MessageServiceService = typeof MessageServiceService;
export const MessageServiceService = {
  getMessages: {
    path: "/app.MessageService/GetMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMessagesRequest): Buffer => Buffer.from(GetMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMessagesRequest => GetMessagesRequest.decode(value),
    responseSerialize: (value: GetMessagesResponse): Buffer => Buffer.from(GetMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMessagesResponse => GetMessagesResponse.decode(value),
  },
  createMessage: {
    path: "/app.MessageService/CreateMessage",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: CreateMessageRequest): Buffer => Buffer.from(CreateMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateMessageRequest => CreateMessageRequest.decode(value),
    responseSerialize: (value: CreateMessageResponse): Buffer =>
      Buffer.from(CreateMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateMessageResponse => CreateMessageResponse.decode(value),
  },
  updateMessage: {
    path: "/app.MessageService/UpdateMessage",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: UpdateMessageRequest): Buffer => Buffer.from(UpdateMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateMessageRequest => UpdateMessageRequest.decode(value),
    responseSerialize: (value: UpdateMessageResponse): Buffer =>
      Buffer.from(UpdateMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateMessageResponse => UpdateMessageResponse.decode(value),
  },
  deleteMessage: {
    path: "/app.MessageService/DeleteMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteMessageRequest): Buffer => Buffer.from(DeleteMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteMessageRequest => DeleteMessageRequest.decode(value),
    responseSerialize: (value: DeleteMessageResponse): Buffer =>
      Buffer.from(DeleteMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteMessageResponse => DeleteMessageResponse.decode(value),
  },
} as const;

export interface MessageServiceServer extends UntypedServiceImplementation {
  getMessages: handleUnaryCall<GetMessagesRequest, GetMessagesResponse>;
  createMessage: handleServerStreamingCall<CreateMessageRequest, CreateMessageResponse>;
  updateMessage: handleServerStreamingCall<UpdateMessageRequest, UpdateMessageResponse>;
  deleteMessage: handleUnaryCall<DeleteMessageRequest, DeleteMessageResponse>;
}

/**
 * ----------------
 * MCP Server
 * ----------------
 */

export interface MCPServerServiceClient {
  getMcpServers(request: GetMCPServersRequest): Observable<GetMCPServersResponse>;

  addMcpServers(request: AddMCPServersRequest): Observable<AddMCPServersResponse>;

  updateMcpServers(request: UpdateMCPServersRequest): Observable<UpdateMCPServersResponse>;

  deleteMcpServers(request: DeleteMCPServersRequest): Observable<DeleteMCPServersResponse>;

  getMcpServerHealth(request: GetMCPServerHealthRequest): Observable<GetMCPServerHealthResponse>;
}

/**
 * ----------------
 * MCP Server
 * ----------------
 */

export interface MCPServerServiceController {
  getMcpServers(
    request: GetMCPServersRequest,
  ): Promise<GetMCPServersResponse> | Observable<GetMCPServersResponse> | GetMCPServersResponse;

  addMcpServers(
    request: AddMCPServersRequest,
  ): Promise<AddMCPServersResponse> | Observable<AddMCPServersResponse> | AddMCPServersResponse;

  updateMcpServers(
    request: UpdateMCPServersRequest,
  ): Promise<UpdateMCPServersResponse> | Observable<UpdateMCPServersResponse> | UpdateMCPServersResponse;

  deleteMcpServers(
    request: DeleteMCPServersRequest,
  ): Promise<DeleteMCPServersResponse> | Observable<DeleteMCPServersResponse> | DeleteMCPServersResponse;

  getMcpServerHealth(
    request: GetMCPServerHealthRequest,
  ): Promise<GetMCPServerHealthResponse> | Observable<GetMCPServerHealthResponse> | GetMCPServerHealthResponse;
}

export function MCPServerServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getMcpServers",
      "addMcpServers",
      "updateMcpServers",
      "deleteMcpServers",
      "getMcpServerHealth",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("MCPServerService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("MCPServerService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const MCP_SERVER_SERVICE_NAME = "MCPServerService";

/**
 * ----------------
 * MCP Server
 * ----------------
 */
export type MCPServerServiceService = typeof MCPServerServiceService;
export const MCPServerServiceService = {
  getMcpServers: {
    path: "/app.MCPServerService/GetMCPServers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMCPServersRequest): Buffer => Buffer.from(GetMCPServersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMCPServersRequest => GetMCPServersRequest.decode(value),
    responseSerialize: (value: GetMCPServersResponse): Buffer =>
      Buffer.from(GetMCPServersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMCPServersResponse => GetMCPServersResponse.decode(value),
  },
  addMcpServers: {
    path: "/app.MCPServerService/AddMCPServers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddMCPServersRequest): Buffer => Buffer.from(AddMCPServersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddMCPServersRequest => AddMCPServersRequest.decode(value),
    responseSerialize: (value: AddMCPServersResponse): Buffer =>
      Buffer.from(AddMCPServersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AddMCPServersResponse => AddMCPServersResponse.decode(value),
  },
  updateMcpServers: {
    path: "/app.MCPServerService/UpdateMCPServers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateMCPServersRequest): Buffer =>
      Buffer.from(UpdateMCPServersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateMCPServersRequest => UpdateMCPServersRequest.decode(value),
    responseSerialize: (value: UpdateMCPServersResponse): Buffer =>
      Buffer.from(UpdateMCPServersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateMCPServersResponse => UpdateMCPServersResponse.decode(value),
  },
  deleteMcpServers: {
    path: "/app.MCPServerService/DeleteMCPServers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteMCPServersRequest): Buffer =>
      Buffer.from(DeleteMCPServersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteMCPServersRequest => DeleteMCPServersRequest.decode(value),
    responseSerialize: (value: DeleteMCPServersResponse): Buffer =>
      Buffer.from(DeleteMCPServersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteMCPServersResponse => DeleteMCPServersResponse.decode(value),
  },
  getMcpServerHealth: {
    path: "/app.MCPServerService/GetMCPServerHealth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMCPServerHealthRequest): Buffer =>
      Buffer.from(GetMCPServerHealthRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMCPServerHealthRequest => GetMCPServerHealthRequest.decode(value),
    responseSerialize: (value: GetMCPServerHealthResponse): Buffer =>
      Buffer.from(GetMCPServerHealthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMCPServerHealthResponse => GetMCPServerHealthResponse.decode(value),
  },
} as const;

export interface MCPServerServiceServer extends UntypedServiceImplementation {
  getMcpServers: handleUnaryCall<GetMCPServersRequest, GetMCPServersResponse>;
  addMcpServers: handleUnaryCall<AddMCPServersRequest, AddMCPServersResponse>;
  updateMcpServers: handleUnaryCall<UpdateMCPServersRequest, UpdateMCPServersResponse>;
  deleteMcpServers: handleUnaryCall<DeleteMCPServersRequest, DeleteMCPServersResponse>;
  getMcpServerHealth: handleUnaryCall<GetMCPServerHealthRequest, GetMCPServerHealthResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
